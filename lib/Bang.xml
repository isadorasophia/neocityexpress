<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Bang</name>
    </assembly>
    <members>
        <member name="T:Bang.ComponentsLookup">
            <summary>
            Implemented by generators in order to provide a mapping of all the types to their respective id.
            </summary>
        </member>
        <member name="P:Bang.ComponentsLookup.ComponentsIndex">
            <summary>
            Maps all the components to their unique id.
            </summary>
        </member>
        <member name="P:Bang.ComponentsLookup.MessagesIndex">
            <summary>
            Maps all the messages to their unique id.
            </summary>
        </member>
        <member name="P:Bang.ComponentsLookup.RelativeComponents">
            <summary>
            List of all the unique id of the components that inherit from <see cref="T:Bang.Components.IParentRelativeComponent"/>.
            </summary>
        </member>
        <member name="F:Bang.ComponentsLookup._untrackedIndices">
            <summary>
            Tracks components and messages without a generator. This query will have a lower performance.
            </summary>
        </member>
        <member name="F:Bang.ComponentsLookup._untrackedRelativeComponents">
            <summary>
            Tracks relative components without a generator. This query will have a lower performance.
            </summary>
        </member>
        <member name="M:Bang.ComponentsLookup.Id(System.Type)">
            <summary>
            Get the id for <paramref name="t"/> component type.
            </summary>
            <param name="t">Type.</param>
        </member>
        <member name="M:Bang.ComponentsLookup.IsRelative(System.Int32)">
            <summary>
            Returns whether a <paramref name="id"/> is relative to its parent.
            </summary>
        </member>
        <member name="T:Bang.Components.IComponent">
            <summary>
            A set of components will define an entity. This can be any sort of game abstraction.
            Bang follows the convetion of only defining components for readonly structs.
            </summary>
        </member>
        <member name="T:Bang.Components.IMessage">
            <summary>
            Messages are a particular type of component which will disappear within the next frame.
            </summary>
        </member>
        <member name="T:Bang.Components.IModifiableComponent">
            <summary>
            This is for a component that can be modified and is not an actual immutable.
            </summary>
        </member>
        <member name="M:Bang.Components.IModifiableComponent.Subscribe(System.Action)">
            <summary>
            Subscribe to receive notifications when the component gets modified.
            </summary>
        </member>
        <member name="M:Bang.Components.IModifiableComponent.Unsubscribe(System.Action)">
            <summary>
            Unsubscribe to receive notifications when the component gets modified.
            </summary>
        </member>
        <member name="T:Bang.Components.IParentRelativeComponent">
            <summary>
            This represents a component which is relative to the parent.
            This will be notified each time that the tracking component of the parent changes.
            </summary>
        </member>
        <member name="M:Bang.Components.IParentRelativeComponent.WithoutParent">
            <summary>
            Creates a copy of the component without any parent.
            </summary>
        </member>
        <member name="P:Bang.Components.IParentRelativeComponent.HasParent">
            <summary>
            Whether the component has a parent that it's tracking.
            </summary>
        </member>
        <member name="M:Bang.Components.IParentRelativeComponent.OnParentModified(Bang.Components.IComponent,Bang.Entities.Entity)">
            <summary>
            Called when a parent gets the <paramref name="parentComponent"/> modified.
            </summary>
            <param name="parentComponent">Component of the parent.</param>
            <param name="childEntity">Child entity tracking the parent.</param>
        </member>
        <member name="T:Bang.Components.ITransformComponent">
            <summary>
            Interface implemented by components that rely on a transform within a world.
            </summary>
        </member>
        <member name="T:Bang.Components.RequiresAttribute">
            <summary>
            This is an attribute that tells that a given component requires another component
            when adding it to the entity.
            This is an attribute that tells that a given data requires another one of the same type.
            For example: a component requires another component when adding it to the entity,
            or a system requires another system when additing it to a world.
            If this is for a system, it assumes that the system that depends on the other one comes first.
            </summary>
        </member>
        <member name="P:Bang.Components.RequiresAttribute.Types">
            <summary>
            System will target all the entities that has all this set of components.
            </summary>
        </member>
        <member name="M:Bang.Components.RequiresAttribute.#ctor(System.Type[])">
            <summary>
            Creates a new <see cref="T:Bang.Components.RequiresAttribute"/>.
            </summary>
            <param name="types">List of components which this depends on.</param>
        </member>
        <member name="T:Bang.Components.UniqueAttribute">
            <summary>
            This is an attribute that tells that a given component is unique within our world.
            We should not expect two entities with the same component if it is declared as unique.
            </summary>
        </member>
        <member name="T:Bang.Components.InteractorMessage">
            <summary>
            A message is a payload immediately fired once an event happens.
            </summary>
        </member>
        <member name="T:Bang.Contexts.ComponentWatcher">
            <summary>
            A context may have a collection of watchers.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ComponentWatcher._entitiesToNotify">
            <summary>
            Tracks the total of entities to notify.
            This will make sure that, even if the same entity has an operation multiple times,
            it will only be passed on once per update.
            Maps:
             [Notification kind -> [Entity id, Entity]]
            </summary>
        </member>
        <member name="M:Bang.Contexts.ComponentWatcher.PopNotifications">
            <summary>
            Get the entities which will be notified.
            This will immediately clear the notification list.
            </summary>
        </member>
        <member name="M:Bang.Contexts.ComponentWatcher.#ctor(Bang.World,System.Int32,System.Type)">
            <summary>
            A watcher will target a single component.
            </summary>
        </member>
        <member name="T:Bang.Contexts.Context">
            <summary>
            Context is the pool of entities accessed by each system that defined it.
            </summary>
        </member>
        <member name="F:Bang.Contexts.Context._entities">
            <summary>
            List of entities which will be fed to the system of this context.
            </summary>
        </member>
        <member name="F:Bang.Contexts.Context._cachedEntities">
            <summary>
            Cached value of the immutable set of entities.
            </summary>
        </member>
        <member name="F:Bang.Contexts.Context._targetComponentsIndex">
            <summary>
            Track the target components and what kind of filter should be performed for each.
            </summary>
        </member>
        <member name="F:Bang.Contexts.Context._componentsOperationKind">
            <summary>
            Track the kind of operation the system will perform for each of the components.
            This is saved as a hash set since we will be using this to check if a certain component is set.
            </summary>
        </member>
        <member name="E:Bang.Contexts.Context.OnComponentAddedForEntityInContext">
            <summary>
            This will be fired when a component is added to an entity present in the system.
            </summary>
        </member>
        <member name="E:Bang.Contexts.Context.OnComponentRemovedForEntityInContext">
            <summary>
            This will be fired when a component is removed from an entity present in the system.
            </summary>
        </member>
        <member name="E:Bang.Contexts.Context.OnComponentModifiedForEntityInContext">
            <summary>
            This will be fired when a component is modified from an entity present in the system.
            </summary>
        </member>
        <member name="E:Bang.Contexts.Context.OnActivateEntityInContext">
            <summary>
            This will be fired when an entity (which was previously disabled) gets enabled.
            </summary>
        </member>
        <member name="E:Bang.Contexts.Context.OnDeactivateEntityInContext">
            <summary>
            This will be fired when an entity (which was previously enabled) gets disabled.
            </summary>
        </member>
        <member name="E:Bang.Contexts.Context.OnMessageSentForEntityInContext">
            <summary>
            This will be fired when a message gets added in an entity present in the system.
            </summary>
        </member>
        <member name="P:Bang.Contexts.Context.IsNoFilter">
            <summary>
            Returns whether this context does not have any filter and grab all entities instead.
            </summary>
        </member>
        <member name="P:Bang.Contexts.Context.Entities">
            <summary>
            Entities that are currently active in the context.
            </summary>
        </member>
        <member name="P:Bang.Contexts.Context.Entity">
            <summary>
            Get the single entity present in the context.
            This assumes that the context targets a unique component.
            TODO: Add flag that checks for unique components within this context.
            </summary>
        </member>
        <member name="P:Bang.Contexts.Context.HasAnyEntity">
            <summary>
            Whether the context has any entity active.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Context.#ctor(Bang.World,Bang.Contexts.ContextAccessorFilter,System.Int32[])">
            <summary>
            Initializes a context that is not necessarily tied to any system.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Context.CalculateId">
            <summary>
            This gets the context unique identifier.
            This is important to get it right since it will be reused across different systems.
            It assumes that we won't get more than 1000 components declared. If this changes (oh! hello!), maybe we should
            reconsider this code.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Context.CreateTargetComponents(System.Collections.Immutable.ImmutableArray{System.ValueTuple{Bang.Systems.FilterAttribute,System.Collections.Immutable.ImmutableArray{System.Int32}}})">
            <summary>
            Create a list of which components we will be watching for when adding a new entity according to a
            <see cref="T:Bang.Contexts.ContextAccessorFilter"/>.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Context.FilterEntity(Bang.Entities.Entity)">
            <summary>
            Filter an entity for the first time in this context.
            This is called when the entity is first created an set into the world.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Context.DoesEntityMatch(Bang.Entities.Entity)">
            <summary>
            Returns whether the entity matches the filter for this context.
            </summary>
        </member>
        <member name="T:Bang.Contexts.ContextAccessorFilter">
            <summary>
            Context accessor filter for a system.
            This will specify the kind of filter which will be performed on a certain list of component types.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ContextAccessorFilter.None">
            <summary>
            No filter is required. This won't be applied when filtering entities to a system.
            This is used when a system will, for example, add a new component to an entity but does
            not require such component.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ContextAccessorFilter.AllOf">
            <summary>
            Only entities which has all of the listed components will be fed to the system.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ContextAccessorFilter.AnyOf">
            <summary>
            Filter entities which has any of the listed components will be fed to the system.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ContextAccessorFilter.NoneOf">
            <summary>
            Filter out entities that have the components listed.
            </summary>
        </member>
        <member name="T:Bang.Contexts.ContextAccessorKind">
            <summary>
            Context accessor kind for a system.
            This will specify the kind of operation that each system will perform, so the world
            can parallelize efficiently each system execution.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ContextAccessorKind.Read">
            <summary>
            This will specify that the system implementation will only perform read operations.
            </summary>
        </member>
        <member name="F:Bang.Contexts.ContextAccessorKind.Write">
            <summary>
            This will specify that the system implementation will only perform write operations.
            </summary>
        </member>
        <member name="T:Bang.Contexts.MessageWatcher">
            <summary>
            A context may have a collection of watchers.
            </summary>
        </member>
        <member name="M:Bang.Contexts.MessageWatcher.#ctor(Bang.World,System.Int32,System.Type)">
            <summary>
            A watcher will target a single component.
            </summary>
        </member>
        <member name="T:Bang.Contexts.Observer">
            <summary>
            Base class for context. This shares implementation for any other class that decides to tweak
            the observer behavior (which hasn't happened yet).
            </summary>
        </member>
        <member name="F:Bang.Contexts.Observer.World">
            <summary>
            World that it observes.
            </summary>
        </member>
        <member name="P:Bang.Contexts.Observer.Entities">
            <summary>
            Entities that are currently watched in the world.
            </summary>
        </member>
        <member name="P:Bang.Contexts.Observer.Id">
            <summary>
            Unique id of the context. 
            This is used when multiple systems share the same context.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Observer.FilterEntity(Bang.Entities.Entity)">
            <summary>
            Filter an entity and observe any changes that happen to its components.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Observer.OnEntityComponentAdded(Bang.Entities.Entity,System.Int32)">
            <summary>
            React to an entity that had some of its components added.
            </summary>
        </member>
        <member name="M:Bang.Contexts.Observer.OnEntityComponentRemoved(Bang.Entities.Entity,System.Int32,System.Boolean)">
            <summary>
            React to an entity that had some of its components removed.
            </summary>
        </member>
        <member name="T:Bang.Contexts.WatcherNotificationKind">
            <summary>
            When a system is watching for a component, this is the kind of notification currently fired.
            </summary>
        </member>
        <member name="F:Bang.Contexts.WatcherNotificationKind.Added">
            <summary>
            Component has been added. It is not called if the entity is dead.
            </summary>
        </member>
        <member name="F:Bang.Contexts.WatcherNotificationKind.Removed">
            <summary>
            Component was removed.
            </summary>
        </member>
        <member name="F:Bang.Contexts.WatcherNotificationKind.Modified">
            <summary>
            Component was modified. It is not called if the entity is dead.
            </summary>
        </member>
        <member name="F:Bang.Contexts.WatcherNotificationKind.Disabled">
            <summary>
            Entity has been disabled, hence all its components.
            </summary>
        </member>
        <member name="F:Bang.Contexts.WatcherNotificationKind.Enabled">
            <summary>
            Entity has been enabled, hence all its components. Called if an entity was
            previously disabled.
            </summary>
        </member>
        <member name="T:Bang.Diagnostics.SmoothCounter">
            <summary>
            Class used to smooth the counter of performance ticks.
            </summary>
        </member>
        <member name="P:Bang.Diagnostics.SmoothCounter.AverageTime">
            <summary>
            Average of counter time value over the sample size.
            </summary>
        </member>
        <member name="P:Bang.Diagnostics.SmoothCounter.AverageEntities">
            <summary>
            Average of entities over the sample size.
            </summary>
        </member>
        <member name="P:Bang.Diagnostics.SmoothCounter.MaximumTime">
            <summary>
            Maximum value over the sample size.
            </summary>
        </member>
        <member name="T:Bang.Entities.Entity">
            <summary>
            An entity is a collection of components within the world.
            This supports hierarchy (parent, children) 
            </summary>
            <summary>
            This file has all the content for entities supporting children
            and parents - a family!
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnComponentAdded">
            <summary>
            This will be fired whenever a new component has been added.
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnComponentRemoved">
            <summary>
            This will be fired whenever a new component has been removed.
            This will send the entity, the component id that was just removed and
            whether this was caused by a destroy.
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnComponentModified">
            <summary>
            This will be fired whenever any component has been replaced.
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnEntityDestroyed">
            <summary>
            This will be fired when the entity gets destroyed.
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnEntityActivated">
            <summary>
            This will be fired when the entity gets activated, so it gets filtered
            back in the context listeners.
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnEntityDeactivated">
            <summary>
            This will be fired when the entity gets deactivated, so it is filtered out
            from its context listeners.
            </summary>
        </member>
        <member name="F:Bang.Entities.Entity._trackedComponentsModified">
            <summary>
            Notifies listeners when a particular component has been modified.
            </summary>
        </member>
        <member name="P:Bang.Entities.Entity.EntityId">
            <summary>
            Entity unique identifier.
            </summary>
        </member>
        <member name="F:Bang.Entities.Entity._world">
            <summary>
            Components lookup. Unique per world that the entity was created.
            </summary>
        </member>
        <member name="P:Bang.Entities.Entity.IsDestroyed">
            <summary>
            Returns whether this entity has been destroyed (and probably recicled) or not.
            </summary>
        </member>
        <member name="F:Bang.Entities.Entity._availableComponents">
            <summary>
            Keeps track of all the components that are currently present.
            </summary>
        </member>
        <member name="P:Bang.Entities.Entity.Components">
            <summary>
            This is used for editor and serialization.
            TODO: Optimize this. For now, this is okay since it's only used once the entity is serialized.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.InitializeComponents(System.Collections.Generic.IEnumerable{Bang.Components.IComponent})">
            <summary>
            Set an entity so it belongs to the world.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.CheckForRequiredComponents">
            <summary>
            This will check whether the entity has all the required components when set to the world.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.HasComponent``1">
            <summary>
            Whether this entity has a component of type T.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.HasComponent(System.Type)">
            <summary>
            Whether this entity has a component of type <paramref name="t"/>.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.TryGetComponent``1(``0@)">
            <summary>
            Try to get a component of type T. If none, returns false and null.
            </summary>
            <typeparam name="T">Type that inherits <see cref="T:Bang.Components.IComponent"/>.</typeparam>
        </member>
        <member name="M:Bang.Entities.Entity.TryGetComponent``1">
            <summary>
            Try to get a component of type T. If none, returns null.
            </summary>
            <typeparam name="T">Type that inherits <see cref="T:Bang.Components.IComponent"/>.</typeparam>
        </member>
        <member name="M:Bang.Entities.Entity.GetComponent``1">
            <summary>
            Fetch a component of type T. If the entity does not have that component, this method will assert and fail.
            </summary>
            <typeparam name="T">Type that inherits <see cref="T:Bang.Components.IComponent"/>.</typeparam>
        </member>
        <member name="M:Bang.Entities.Entity.GetComponent``1(System.Int32)">
            <summary>
            Fetch a component of type T with <paramref name="index"/>. 
            If the entity does not have that component, this method will assert and fail.
            </summary>
            <typeparam name="T">Type that inherits <see cref="T:Bang.Components.IComponent"/>.</typeparam>
        </member>
        <member name="M:Bang.Entities.Entity.AddComponentOnce``1">
            <summary>
            Add an empty component only once to the entity.
            </summary>
            <returns>
            Whether a new component was added.
            </returns>
        </member>
        <member name="M:Bang.Entities.Entity.AddComponent(Bang.Components.IComponent,System.Type)">
            <summary>
            Add a component <paramref name="c"/> of type <paramref name="t"/>.
            </summary>
            <param name="c">Component.</param>
            <param name="t">Type of the component.</param>
        </member>
        <member name="M:Bang.Entities.Entity.AddComponent``1(``0)">
            <summary>
            Add component <paramref name="c"/> to this entity.
            </summary>
            <typeparam name="T">Type that inherits from <see cref="T:Bang.Components.IComponent"/>.</typeparam>
            <param name="c">Component.</param>
            <returns>Entity (this).</returns>
        </member>
        <member name="M:Bang.Entities.Entity.RemoveComponent(System.Type)">
            <summary>
            Removes component of type <paramref name="t"/>.
            Do nothing if <paramref name="t"/> is not owned by this entity.
            </summary>
            <param name="t">Type of the component.</param>
        </member>
        <member name="M:Bang.Entities.Entity.RemoveComponent``1">
            <summary>
            Removes component of type <typeparamref name="T"/>.
            Do nothing if <typeparamref name="T"/> is not owned by this entity.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.ReplaceComponent(Bang.Components.IComponent,System.Type,System.Boolean)">
            <summary>
            Replace componenent of type <paramref name="t"/> with <paramref name="c"/>.
            This asserts if the component does not exist or is not assignable from <paramref name="t"/>.
            Do nothing if the entity has been destroyed.
            </summary>
            <param name="c">Component.</param>
            <param name="t">Target component type.</param>
            <param name="forceReplace">Whether the component will be forcefully replaced.</param>
        </member>
        <member name="M:Bang.Entities.Entity.ReplaceComponent``1(``0)">
            <summary>
            Replace componenent of type <typeparamref name="T"/> with <paramref name="c"/>.
            This asserts if the component does not exist or is not assignable from <typeparamref name="T"/>.
            Do nothing if the entity has been destroyed.
            </summary>
            <param name="c">Component.</param>
        </member>
        <member name="M:Bang.Entities.Entity.AddOrReplaceComponent``1(``0)">
            <summary>
            Add or replace component of type <typeparamref name="T"/> with <paramref name="c"/>.
            Do nothing if the entity has been destroyed.
            </summary>
            <typeparam name="T">Target type that <paramref name="c"/> is assignable.</typeparam>
            <param name="c">Component.</param>
        </member>
        <member name="M:Bang.Entities.Entity.AddOrReplaceComponent(Bang.Components.IComponent,System.Type)">
            <summary>
            Add or replace component of type <paramref name="t"/> with <paramref name="c"/>.
            Do nothing if the entity has been destroyed.
            </summary>
            <param name="c">Component.</param>
            <param name="t">Target type that <paramref name="c"/> is assignable.</param>
        </member>
        <member name="M:Bang.Entities.Entity.AddOrReplaceComponent``1(``0,System.Int32)">
            <summary>
            Add or replace component of type <typeparamref name="T"/> with <paramref name="c"/>.
            Do nothing if the entity has been destroyed.
            </summary>
            <typeparam name="T">Target type that <paramref name="c"/> is assignable.</typeparam>
            <param name="c">Component.</param>
            <param name="index">Identifier ot the component type.</param>
        </member>
        <member name="M:Bang.Entities.Entity.HasComponent(System.Int32)">
            <summary>
            Checks whether an entity has a component.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.HasComponentOrMessage(System.Int32)">
            <summary>
            Checks whether an entity has a data attached to -- component or message.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.AddComponentInternal``1(``0,System.Int32)">
            <summary>
            This simply adds a component to our lookup table. This won't do anything fancy other than
            booking it, if it happens to exceed the components length.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.AddComponent``1(``0,System.Int32)">
            <summary>
            Add a component to the entity.
            Returns true if the element existed and was replaced.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.ReplaceComponent``1(``0,System.Int32,System.Boolean)">
            <summary>
            Replace a component from the entity.
            Returns true if the element existed and was replaced.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.RemoveComponent(System.Int32)">
            <summary>
            Remove a component from the entity.
            Returns true if the element existed and was removed.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.NotifyAndSubscribeOnComponentAdded(System.Int32,Bang.Components.IComponent)">
            <summary>
            When adding a component:
              1. If this is a modifiable component, we must subscribe to the new component.
              2. If this is a state machine component, start it up.
              3. Notify subscribers that the component has been added.
              4. If this is a component that relies on the parent, make sure we are
                 tracking the parent changes.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.NotifyOnComponentReplaced(System.Int32,Bang.Components.IComponent)">
            <summary>
            When changing a component:
              1. If this is a modifiable component, we have replaced the component with a new object.
                 Make sure we subcribe to the new component.
              2. If this is a state machine component, start it up.
              3. Notify subscribers that the component has been modified.
              4. Notify any children about the value change.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.Destroy">
            <summary>
            Destroy the entity from the world.
            This will notify all components that it will be removed from the entity.
            At the end of the update of the frame, it will wipe this entity from the world.
            However, if someone still holds reference to an <see cref="T:Bang.Entities.Entity"/> (they shouldn't),
            they might see a zombie entity after this.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.Destroy(System.Int32)">
            <summary>
            Entity has been destroyed due to <paramref name="_"/>.
            </summary>
            <param name="_">Parent id.</param>
        </member>
        <member name="M:Bang.Entities.Entity.Dispose">
            <summary>
            Dispose the entity.
            This will unparent and remove all components.
            It also removes subscription from all their contexts or entities.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.NotifyRemovalOnDestroy(System.Int32)">
            <summary>
            Notify that a component will be removed on the end of the frame due to a <see cref="M:Bang.Entities.Entity.Destroy(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Bang.Entities.Entity._children">
            <summary>
            All the children tracked by the entity.
            Maps:
              [Child id => Child name]
            </summary>
        </member>
        <member name="F:Bang.Entities.Entity._childrenPerName">
            <summary>
            All the children tracked by the entity.
            Maps:
              [Child name => Child id]
            </summary>
        </member>
        <member name="P:Bang.Entities.Entity.Parent">
            <summary>
            This is the unique id of the parent of the entity.
            Null if none (no parent).
            </summary>
        </member>
        <member name="P:Bang.Entities.Entity.Children">
            <summary>
            Unique id of all the children of the entity.
            </summary>
        </member>
        <member name="P:Bang.Entities.Entity.FetchChildrenWithNames">
            <summary>
            Fetch a list of all the unique identifiers of the children with their respective names.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.TryFetchChild(System.String)">
            <summary>
            Try to fetch a child with a <paramref name="name"/> identifier
            </summary>
            <param name="name">The name of the child.</param>
            <returns>Child entity, if any.</returns>
        </member>
        <member name="M:Bang.Entities.Entity.TryFetchParent">
            <summary>
            Try to fetch the parent entity.
            </summary>
            <returns>Parent entity. If none, returns null.</returns>
        </member>
        <member name="M:Bang.Entities.Entity.TryFetchChildWithComponent``1">
            <summary>
            This fetches a child with a given component.
            TODO: Optimize, or cache?
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.TrackComponent(System.Int32,System.Action{System.Int32,Bang.Components.IComponent})">
            <summary>
            Track whenever a component of index <paramref name="index"/> gets modified.
            This is used by the entity's children in order to track a component changes.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.UntrackComponent(System.Int32,System.Action{System.Int32,Bang.Components.IComponent})">
            <summary>
            Untracks whenever a component of index <paramref name="index"/> gets modified.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.AddChild(System.Int32,System.String)">
            <summary>
            Assign an existing entity as a child.
            </summary>
            <param name="id">Id of the entity.</param>
            <param name="name">Name of the child (if none, null).</param>
        </member>
        <member name="M:Bang.Entities.Entity.HasChild(System.String)">
            <summary>
            Try to fetch a child with a <paramref name="name"/> identifier
            </summary>
            <param name="name">The name of the child.</param>
            <returns>Child entity, if any.</returns>
        </member>
        <member name="M:Bang.Entities.Entity.HasChild(System.Int32)">
            <summary>
            Try to fetch a child with a <paramref name="entityId"/> entity identifier.
            </summary>
            <param name="entityId">The entity id of the child.</param>
        </member>
        <member name="M:Bang.Entities.Entity.RemoveChild(System.String)">
            <summary>
            Remove a child from the entity.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.RemoveChild(System.Int32)">
            <summary>
            Remove a child from the entity.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.Reparent(Bang.Entities.Entity)">
            <summary>
            Set the parent of this entity.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.Unparent">
            <summary>
            This will remove a parent of the entity.
            It untracks all the tracked components and removes itself from the parent's children.
            </summary>
        </member>
        <member name="E:Bang.Entities.Entity.OnMessage">
            <summary>
            This will be fired when a message gets sent to the entity.
            </summary>
        </member>
        <member name="F:Bang.Entities.Entity._messages">
            <summary>
            Track message components. This will be added within an update.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.HasMessage``1">
            <summary>
            Whether entity has a message of type <typeparamref name="T"/>.
            This should be avoided since it highly depends on the order of the systems
            being fired and can lead to several bugs.
            For example, if we check for that on the state machine, it will depend on the order
            of the entities in the world.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.HasMessage(System.Int32)">
            <summary>
            Whether entity has a message of index <paramref name="index"/>.
            This should be avoided since it highly depends on the order of the systems
            being fired and can lead to several bugs.
            For example, if we check for that on the state machine, it will depend on the order
            of the entities in the world.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.SendMessage``1">
            <summary>
            Sends a message of type <typeparamref name="T"/> for any system watching it.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.SendMessage``1(``0)">
            <summary>
            Sends a message of type <typeparamref name="T"/> for any system watching it.
            This will also send a body message through <paramref name="message"/>.
            </summary>
        </member>
        <member name="M:Bang.Entities.Entity.ClearMessages">
            <summary>
            Clear all pending messages.
            </summary>
        </member>
        <member name="T:Bang.Interactions.IInteractiveComponent">
            <summary>
            This is a component which will interact with another entity.
            </summary>
        </member>
        <member name="M:Bang.Interactions.IInteractiveComponent.Interact(Bang.World,Bang.Entities.Entity,Bang.Entities.Entity)">
            <summary>
            This is the logic which will be immediately called once the <paramref name="interactor"/> interacts with the
            <paramref name="interacted"/>.
            </summary>
        </member>
        <member name="T:Bang.Interactions.Interaction">
            <summary>
            An interaction is any logic which will be immediately sent to another entity.
            </summary>
        </member>
        <member name="M:Bang.Interactions.Interaction.Interact(Bang.World,Bang.Entities.Entity,Bang.Entities.Entity)">
            <summary>
            Contract immediately performed once <paramref name="interactor"/> interacts with <paramref name="interacted"/>.
            </summary>
        </member>
        <member name="T:Bang.Interactions.InteractiveComponent`1">
            <summary>
            Implements an interaction component which will be passed on to the entity.
            </summary>
        </member>
        <member name="M:Bang.Interactions.InteractiveComponent`1.#ctor">
            <summary>
            Default constructor initialize a brand new interaction.
            </summary>
        </member>
        <member name="M:Bang.Interactions.InteractiveComponent`1.#ctor(`0)">
            <summary>
            Creates a new <see cref="T:Bang.Interactions.InteractiveComponent`1"/>.
            </summary>
        </member>
        <member name="M:Bang.Interactions.InteractiveComponent`1.Interact(Bang.World,Bang.Entities.Entity,Bang.Entities.Entity)">
            <summary>
            This calls the inner interaction component.
            </summary>
        </member>
        <member name="M:Bang.Interactions.InteractiveComponent`1.Unsubscribe(System.Action)">
            <summary>
            Stop listening to notifications on this component.
            </summary>
        </member>
        <member name="M:Bang.Interactions.InteractiveComponent`1.Subscribe(System.Action)">
            <summary>
            Subscribe for notifications on this component.
            </summary>
        </member>
        <member name="T:Bang.Interactions.InteractorComponent">
            <summary>
            This component is to signalize that an entity is able to interact with other objects.
            </summary>
        </member>
        <member name="T:Bang.StateMachines.IStateMachineComponent">
            <summary>
            See <see cref="T:Bang.StateMachines.StateMachine"/> for more details. This is the component implementation.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.IStateMachineComponent.Initialize(Bang.World,Bang.Entities.Entity)">
            <summary>
            Initialize the state machine with the world knowledge. Called before any tick.
            </summary>
        </member>
        <member name="P:Bang.StateMachines.IStateMachineComponent.State">
            <summary>
            Name of the state machine. This is mostly used to debug.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.IStateMachineComponent.Tick(System.Single)">
            <summary>
            Tick a yield operation in the state machine. The next tick will be called according to the returned <see cref="T:Bang.StateMachines.WaitKind"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.IStateMachineComponent.OnDestroyed">
            <summary>
            Called right before the component gets destroyed.
            </summary>
        </member>
        <member name="T:Bang.StateMachines.StateMachine">
            <summary>
            This is a basic state machine for an entity.
            It is sort-of anti-pattern of ECS at this point. This is a trade-off
            between adding content and using ECS at the core of the game.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._cachedPersistedState">
            <summary>
            This is the only property of the state machine we will actually persist.
            This will keep track of the last state of the state machine.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine.World">
            <summary>
            World of the state machine.
            Initialized in <see cref="M:Bang.StateMachines.StateMachine.Initialize(Bang.World,Bang.Entities.Entity)"/>.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine.Entity">
            <summary>
            Entity of the state machine.
            Initialized in <see cref="M:Bang.StateMachines.StateMachine.Initialize(Bang.World,Bang.Entities.Entity)"/>.
            </summary>
        </member>
        <member name="P:Bang.StateMachines.StateMachine.Name">
            <summary>
            Name of the active state. Used for debug.
            </summary>
        </member>
        <member name="E:Bang.StateMachines.StateMachine.OnModified">
            <summary>
            Called when the state changes.
            Should only be called by the state machine component, see <see cref="T:Bang.StateMachines.StateMachineComponent`1"/>.
            </summary>
        </member>
        <member name="P:Bang.StateMachines.StateMachine.CurrentState">
            <summary>
            Current state, represented by <see cref="P:Bang.StateMachines.StateMachine.Name"/>.
            Tracked if we ever need to reset to the start of the state.
            </summary>
        </member>
        <member name="P:Bang.StateMachines.StateMachine.Routine">
            <summary>
            The routine the entity is currently executing.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._waitTime">
            <summary>
            Track any wait time before calling the next Tick.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._waitFrames">
            <summary>
            Track any amount of frames before calling the next Tick.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._routinesOnWait">
            <summary>
            Routine which we might be currently waiting on, before resuming to <see cref="P:Bang.StateMachines.StateMachine.Routine"/>.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._waitForMessage">
            <summary>
            Track the message we are waiting for.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._waitForMessageTarget">
            <summary>
            Target entity for <see cref="F:Bang.StateMachines.StateMachine._waitForMessage"/>.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._isMessageReceived">
            <summary>
            Tracks whether a message which was waited has been received.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.StateMachine._isFirstTick">
            <summary>
            Whether this was the first time a tick was executed.
            Used to call <see cref="M:Bang.StateMachines.StateMachine.OnStart"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.Initialize(Bang.World,Bang.Entities.Entity)">
            <summary>
            Initialize the state machine. 
            Should only be called by the entity itself when it is registered in the world.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.OnStart">
            <summary>
            Initialize the state machine. Called before the first <see cref="M:Bang.StateMachines.StateMachine.Tick(System.Single)"/> call.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.Tick(System.Single)">
            <summary>
            Tick an update.
            Should only be called by the state machine component, see <see cref="T:Bang.StateMachines.StateMachineComponent`1"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.OnDestroyed">
            <summary>
            Clean up right before the state machine gets cleaned up.
            Callers must call the base implementation.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.Reset">
            <summary>
            This resets the current state of the state machine back to the beggining of that same state.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.GoTo(System.Func{System.Collections.Generic.IEnumerator{Bang.StateMachines.Wait}})">
            <summary>
            Redirects the state machine to a new <paramref name="routine"/>.
            </summary>
            <param name="routine">Target routine (new state).</param>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.State(System.Func{System.Collections.Generic.IEnumerator{Bang.StateMachines.Wait}})">
            <summary>
            Set the current state of the state machine with <paramref name="routine"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachine.OnMessage(Bang.Components.IMessage)">
            <summary>
            Implemented by state machine implementations that want to listen to message
            notifications from outer systems.
            </summary>
        </member>
        <member name="T:Bang.StateMachines.StateMachineComponent`1">
            <summary>
            Implements a state machine component.
            </summary>
        </member>
        <member name="P:Bang.StateMachines.StateMachineComponent`1.State">
            <summary>
            This will fire a notification whenever the state changes.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.#ctor">
            <summary>
            Creates a new <see cref="T:Bang.StateMachines.StateMachineComponent`1"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.#ctor(`0)">
            <summary>
            Default constructor initialize a brand new routine.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.Initialize(Bang.World,Bang.Entities.Entity)">
            <summary>
            Initialize the state machine with the world knowledge. Called before any tick.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.Tick(System.Single)">
            <summary>
            Tick a yield operation in the state machine. The next tick will be called according to the returned <see cref="T:Bang.StateMachines.WaitKind"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.OnDestroyed">
            <summary>
            Called right before the component gets destroyed.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.Unsubscribe(System.Action)">
            <summary>
            Stop listening to notifications on this component.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.StateMachineComponent`1.Subscribe(System.Action)">
            <summary>
            Subscribe for notifications on this component.
            </summary>
        </member>
        <member name="T:Bang.StateMachines.Wait">
            <summary>
            This is a message fired to communicate the current state of the state machine.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.Wait.Kind">
            <summary>
            When should the state machine be called again.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.Wait.Value">
            <summary>
            Integer value, if kind is <see cref="F:Bang.StateMachines.WaitKind.Ms"/> or <see cref="F:Bang.StateMachines.WaitKind.Frames"/>.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.Wait.Component">
            <summary>
            Used for <see cref="F:Bang.StateMachines.WaitKind.Message"/>.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.Wait.Target">
            <summary>
            Used for <see cref="F:Bang.StateMachines.WaitKind.Message"/> when waiting on another entity that is not the owner of the state machine.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.Wait.Routine">
            <summary>
            Used for <see cref="F:Bang.StateMachines.WaitKind.Routine"/>.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.Wait.Stop">
            <summary>
            No longer execute the state machine.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.Wait.ForMs(System.Int32)">
            <summary>
            Wait for <paramref name="ms"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.Wait.ForSeconds(System.Single)">
            <summary>
            Wait for <paramref name="seconds"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.Wait.ForMessage``1">
            <summary>
            Wait until message of type <typeparamref name="T"/> is fired.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.Wait.ForMessage``1(Bang.Entities.Entity)">
            <summary>
            Wait until message of type <typeparamref name="T"/> is fired from <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.Wait.ForFrames(System.Int32)">
            <summary>
            Wait until <paramref name="frames"/> have occurred.
            </summary>
        </member>
        <member name="P:Bang.StateMachines.Wait.NextFrame">
            <summary>
            Wait until the next frame.
            </summary>
        </member>
        <member name="M:Bang.StateMachines.Wait.ForRoutine(System.Collections.Generic.IEnumerator{Bang.StateMachines.Wait})">
            <summary>
            Wait until <paramref name="routine"/> finishes.
            </summary>
        </member>
        <member name="T:Bang.StateMachines.WaitKind">
            <summary>
            Wait between state machine calls.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.WaitKind.Stop">
            <summary>
            Stops the state machine execution.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.WaitKind.Ms">
            <summary>
            Wait for 'x' ms.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.WaitKind.Message">
            <summary>
            Wait for a message to be fired.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.WaitKind.Frames">
            <summary>
            Wait for 'x' frames.
            </summary>
        </member>
        <member name="F:Bang.StateMachines.WaitKind.Routine">
            <summary>
            Redirect execution to another routine. This will resume once that's finished.
            </summary>
        </member>
        <member name="T:Bang.Systems.DoNotPauseAttribute">
            <summary>
            Indicates that a system will not be deactivated on pause.
            </summary>
        </member>
        <member name="T:Bang.Systems.FilterAttribute">
            <summary>
            Indicates characteristics of a system that was implemented on our ECS system.
            This must be implemented by all the systems that inherits from <see cref="T:Bang.Systems.ISystem"/>.
            </summary>
        </member>
        <member name="P:Bang.Systems.FilterAttribute.Types">
            <summary>
            System will target all the entities that has all this set of components.
            </summary>
        </member>
        <member name="P:Bang.Systems.FilterAttribute.Kind">
            <summary>
            This is the kind of accessor that will be made on this component.
            This can be leveraged once we parallelize update frames (which we don't yet), so don't bother with this just yet.
            </summary>
        </member>
        <member name="P:Bang.Systems.FilterAttribute.Filter">
            <summary>
            This is how the system will filter the entities. See <see cref="T:Bang.Contexts.ContextAccessorFilter"/>.
            </summary>
        </member>
        <member name="M:Bang.Systems.FilterAttribute.#ctor(Bang.Contexts.ContextAccessorFilter,Bang.Contexts.ContextAccessorKind,System.Type[])">
            <summary>
            Creates a system filter with custom accessors.
            </summary>
        </member>
        <member name="M:Bang.Systems.FilterAttribute.#ctor(Bang.Contexts.ContextAccessorFilter,System.Type[])">
            <summary>
            Create a system filter with default accessor of <see cref="P:Bang.Systems.FilterAttribute.Kind"/> for <paramref name="types"/>.
            </summary>
        </member>
        <member name="M:Bang.Systems.FilterAttribute.#ctor(Bang.Contexts.ContextAccessorKind,System.Type[])">
            <summary>
            Create a system filter with default accessor of <see cref="P:Bang.Systems.FilterAttribute.Filter"/> for <paramref name="types"/>.
            </summary>
        </member>
        <member name="M:Bang.Systems.FilterAttribute.#ctor(System.Type[])">
            <summary>
            Create a system filter with default accessors for <paramref name="types"/>.
            </summary>
        </member>
        <member name="T:Bang.Systems.IExitSystem">
            <summary>
            This is the system called when the world is shutting down.
            </summary>
        </member>
        <member name="M:Bang.Systems.IExitSystem.Exit(Bang.Contexts.Context)">
            <summary>
            Called when everything is turning off (this is your last chance).
            </summary>
        </member>
        <member name="T:Bang.Systems.IFixedUpdateSystem">
            <summary>
            System which will be called in fixed intervals.
            </summary>
        </member>
        <member name="M:Bang.Systems.IFixedUpdateSystem.FixedUpdate(Bang.Contexts.Context)">
            <summary>
            Update calls which will be called in fixed intervals.
            </summary>
            <param name="context">Context which will filter the entities.</param>
        </member>
        <member name="T:Bang.Systems.IMessagerSystem">
            <summary>
            A reactive system that reacts whenever a message gets added to an entity.
            </summary>
        </member>
        <member name="M:Bang.Systems.IMessagerSystem.OnMessage(Bang.World,Bang.Entities.Entity,Bang.Components.IMessage)">
            <summary>
            Called once a message is fired from <paramref name="entity"/>.
            </summary>
        </member>
        <member name="T:Bang.Systems.IReactiveSystem">
            <summary>
            A reactive system that reacts to changes of certain components.
            </summary>
        </member>
        <member name="M:Bang.Systems.IReactiveSystem.OnAdded(Bang.World,System.Collections.Immutable.ImmutableArray{Bang.Entities.Entity})">
            <summary>
            This is called at the end of the frame for all entities which were added one of the target
            components.
            This is not called if the entity died.
            </summary>
        </member>
        <member name="M:Bang.Systems.IReactiveSystem.OnRemoved(Bang.World,System.Collections.Immutable.ImmutableArray{Bang.Entities.Entity})">
            <summary>
            This is called at the end of the frame for all entities which removed one of the target
            components.
            </summary>
        </member>
        <member name="M:Bang.Systems.IReactiveSystem.OnModified(Bang.World,System.Collections.Immutable.ImmutableArray{Bang.Entities.Entity})">
            <summary>
            This is called at the end of the frame for all entities which modified one of the target
            components.
            This is not called if the entity died.
            </summary>
        </member>
        <member name="M:Bang.Systems.IReactiveSystem.OnActivated(Bang.World,System.Collections.Immutable.ImmutableArray{Bang.Entities.Entity})">
            <summary>
            [Optional] This is called when an entity gets enabled.
            </summary>
        </member>
        <member name="M:Bang.Systems.IReactiveSystem.OnDeactivated(Bang.World,System.Collections.Immutable.ImmutableArray{Bang.Entities.Entity})">
            <summary>
            [Optional] This is called when an entity gets disabled. Called if an entity was
            previously disabled.
            </summary>
        </member>
        <member name="T:Bang.Systems.IRenderSystem">
            <summary>
            Must be leveraged by engine implementations of render functionality.
            </summary>
        </member>
        <member name="T:Bang.Systems.IStartupSystem">
            <summary>
            A startup system is only called once the world starts.
            </summary>
        </member>
        <member name="M:Bang.Systems.IStartupSystem.Start(Bang.Contexts.Context)">
            <summary>
            This is called before any <see cref="M:Bang.Systems.IUpdateSystem.Update(Bang.Contexts.Context)"/> call.
            </summary>
        </member>
        <member name="T:Bang.Systems.ISystem">
            <summary>
            A system will run through all entities that satisfy its filters at once.
            </summary>
        </member>
        <member name="T:Bang.Systems.IUpdateSystem">
            <summary>
            This is the update system and consists of a single update call.
            </summary>
        </member>
        <member name="M:Bang.Systems.IUpdateSystem.Update(Bang.Contexts.Context)">
            <summary>
            Update method. Called once each frame.
            </summary>
        </member>
        <member name="T:Bang.Systems.MessagerAttribute">
            <summary>
            Indicates a messager attribute for a system.
            This must be implemented by all the systems that inherits from <see cref="T:Bang.Systems.IMessagerSystem"/>.
            </summary>
        </member>
        <member name="P:Bang.Systems.MessagerAttribute.Type">
            <summary>
            System will target all the entities that has all this set of components.
            </summary>
        </member>
        <member name="M:Bang.Systems.MessagerAttribute.#ctor(System.Type)">
            <summary>
            Creates a new <see cref="T:Bang.Systems.MessagerAttribute"/>.
            </summary>
            <param name="type">Message which will be fired to this system.</param>
        </member>
        <member name="T:Bang.Systems.OnPauseAttribute">
            <summary>
            Indicates that a system will not be deactivated on pause.
            </summary>
        </member>
        <member name="T:Bang.Systems.WatchAttribute">
            <summary>
            Indicates a watcher attribute for a system.
            This must be implemented by all the systems that inherits from <see cref="T:Bang.Systems.IReactiveSystem"/>.
            </summary>
        </member>
        <member name="P:Bang.Systems.WatchAttribute.Types">
            <summary>
            System will target all the entities that has all this set of components.
            </summary>
        </member>
        <member name="M:Bang.Systems.WatchAttribute.#ctor(System.Type[])">
            <summary>
            Creates a new <see cref="T:Bang.Systems.WatchAttribute"/> with a set of target types.
            </summary>
            <param name="types">Component types which will fire a notification once they are modified.</param>
        </member>
        <member name="M:Bang.Util.HashExtensions.GetHashCodeImpl(System.Collections.Generic.IEnumerable{System.Int32})">
            <summary>
            Algorithm taken from: https://stackoverflow.com/a/3405330.
            This is a reasonable algorithm for array of values between -1000 and 1000. We can replace this afterwards if there is a need.
            </summary>
            <param name="values">Values which will be applied the hash algorithm.</param>
        </member>
        <member name="T:Bang.World">
            <summary>
            This is the internal representation of a world within ECS.
            A world has the knowledge of all the entities and all the systems that exist within the game.
            This handles dispatching information and handling disposal of entities.
            </summary>
            <summary>
            This will expose debug information used when creating a world.
            </summary>
            <summary>
            Reflection helper utility to access the world.
            </summary>
        </member>
        <member name="F:Bang.World.DIAGNOSTICS_MODE">
            <summary>
            Use this to set whether diagnostics should be pulled from the world run.
            </summary>
        </member>
        <member name="P:Bang.World.SystemInfo.Order">
            <summary>
            Executing order of the system.
            Unique within the world.
            </summary>
        </member>
        <member name="F:Bang.World._cachedStartupSystems">
            <summary>
            The startup systems will be called the first time they are activated.
            We will keep the systems here even after they were deactivated.
            </summary>
        </member>
        <member name="F:Bang.World._cachedRenderSystems">
            <summary>
            This must be called by engine implementations of Bang to handle with rendering.
            </summary>
        </member>
        <member name="F:Bang.World._watchersTriggered">
            <summary>
            Tracks down all the watchers id that require a notification operation.
            </summary>
        </member>
        <member name="P:Bang.World.AnyPendingWatchers">
            <summary>
            Whether there are any pending watchers.
            </summary>
        </member>
        <member name="F:Bang.World._entitiesTriggeredByMessage">
            <summary>
            Tracks down all the entities which received a message notification within the frame.
            </summary>
        </member>
        <member name="F:Bang.World._systems">
            <summary>
            Tracks all registered systems across the world, regardless if they are active or not.
            Maps: System order id -> (IsActive, ContextId).
            </summary>
        </member>
        <member name="F:Bang.World.IdToSystem">
            <summary>
            Used when fetching systems based on its unique identifier.
            Maps: System order id -> System instance.
            </summary>
        </member>
        <member name="F:Bang.World._typeToSystems">
            <summary>
            Maps: System type -> System id.
            </summary>
        </member>
        <member name="F:Bang.World._pauseSystems">
            <summary>
            Set of systems which will be paused. See <see cref="M:Bang.World.IsPauseSystem(Bang.Systems.ISystem)"/> for more information.
            </summary>
        </member>
        <member name="F:Bang.World._playOnPauseSystems">
            <summary>
            Set of systems which will only be played once a pause occur.
            </summary>
        </member>
        <member name="F:Bang.World._systemsToResume">
            <summary>
            List of systems which will be resumed after a pause.
            These are the systems which were deactivated due to <see cref="M:Bang.World.Pause"/>.
            </summary>
        </member>
        <member name="F:Bang.World.Contexts">
            <summary>
            Maps all the context IDs with the context.
            We might add new ones if a system calls for a new context filter.
            </summary>
        </member>
        <member name="F:Bang.World._watchers">
            <summary>
            Maps all the watcher IDs.
            Maps: Watcher Ids -> (Watcher, Systems that subscribe to this watcher).
            </summary>
        </member>
        <member name="F:Bang.World._messagers">
            <summary>
            Maps all the messagers IDs.
            Maps: Messager Ids -> (Messager, Systems that subscribe to this messager).
            </summary>
        </member>
        <member name="F:Bang.World._cacheUniqueContexts">
            <summary>
            Cache all the unique contexts according to the component type.
            Maps: Unique component type -> Context id.
            </summary>
        </member>
        <member name="F:Bang.World._entities">
            <summary>
            Entities that exist within our world.
            TODO: Do we want some sort of object pooling here?
            Right now, if we remove entities, we will set the id to null.
            </summary>
        </member>
        <member name="F:Bang.World._deactivatedEntities">
            <summary>
            Entities which have been temporarily deactivated in the world.
            </summary>
        </member>
        <member name="F:Bang.World._pendingDestroyEntities">
            <summary>
            Entities that we will destroy within the world.
            </summary>
        </member>
        <member name="F:Bang.World._nextEntityId">
            <summary>
            Entity count, used for generating the next id.
            </summary>
        </member>
        <member name="P:Bang.World.IsPaused">
            <summary>
            Whether the world has been queried to be on pause or not.
            See <see cref="M:Bang.World.Pause"/>.
            </summary>
        </member>
        <member name="F:Bang.World.ComponentsLookup">
            <summary>
            Map of all the components index across the world.
            </summary>
        </member>
        <member name="M:Bang.World.#ctor(System.Collections.Generic.IList{System.ValueTuple{Bang.Systems.ISystem,System.Boolean}})">
            <summary>
            Initialize the world!
            </summary>
            <param name="systems">List of systems and whether they are currently active in the world.</param>
            <exception cref="T:System.ArgumentException">If no systems are passed to the world.</exception>
        </member>
        <member name="M:Bang.World.AddEntity">
            <summary>
            Add a new empty entity to the world. 
            This will map the instance to the world.
            Any components added after this entity has been created will be notified to any reactive systems.
            </summary>
        </member>
        <member name="M:Bang.World.AddEntity(Bang.Components.IComponent[])">
            <summary>
            Add a single entity to the world (e.g. collection of <paramref name="components"/>). 
            This will map the instance to the world.
            </summary>
        </member>
        <member name="M:Bang.World.AddEntity(System.Collections.Generic.IEnumerable{Bang.Components.IComponent})">
            <summary>
            Add a single entity to the world (e.g. collection of <paramref name="components"/>). 
            This will map the instance to the world.
            </summary>
        </member>
        <member name="M:Bang.World.AddEntity(System.Nullable{System.Int32},System.Collections.Generic.IEnumerable{Bang.Components.IComponent})">
            <summary>
            Add a single entity to the world (e.g. collection of <paramref name="components"/>). 
            This will map the instance to the world and add an entity with an existing id.
            </summary>
        </member>
        <member name="M:Bang.World.AddEntity(Bang.Entities.Entity)">
            <summary>
            Add a single entity to the world. This will map the instance to the world.
            Any components added after this entity has been created will be notified to any reactive systems.
            </summary>
        </member>
        <member name="M:Bang.World.CheckEntityId(System.Nullable{System.Int32})">
            <summary>
            This will take <paramref name="id"/> and provide an entity id
            which has not been used by any other entity in the world.
            </summary>
        </member>
        <member name="M:Bang.World.RegisterToRemove(System.Int32)">
            <summary>
            Register that an entity must be removed in the end of the frame.
            </summary>
        </member>
        <member name="M:Bang.World.DestroyPendingEntities">
            <summary>
            Destroy all the pending entities within the frame.
            </summary>
        </member>
        <member name="M:Bang.World.RemoveEntity(System.Int32)">
            <summary>
            Removes an entity with <paramref name="id"/> from the world.
            </summary>
        </member>
        <member name="M:Bang.World.ActivateEntity(System.Int32)">
            <summary>
            Activates an entity in the world.
            Only called by an <see cref="T:Bang.Entities.Entity"/>.
            </summary>
        </member>
        <member name="M:Bang.World.DeactivateEntity(System.Int32)">
            <summary>
            Deactivate an entity in the world.
            Only called by an <see cref="T:Bang.Entities.Entity"/>.
            </summary>
        </member>
        <member name="M:Bang.World.GetEntity(System.Int32)">
            <summary>
            Get an entity with the specific id.
            </summary>
        </member>
        <member name="M:Bang.World.TryGetEntity(System.Int32)">
            <summary>
            Tries to get an entity with the specific id.
            If the entity is no longer among us, return null.
            </summary>
        </member>
        <member name="M:Bang.World.GetAllEntities">
            <summary>
            This should be used very cautiously! I hope you know what you are doing.
            It fetches all the entities within the world and return them.
            </summary>
        </member>
        <member name="M:Bang.World.IsSystemActive(System.Type)">
            <summary>
            Whether a system is active within the world.
            </summary>
        </member>
        <member name="M:Bang.World.ActivateSystem``1">
            <summary>
            Activate a system within our world.
            </summary>
        </member>
        <member name="M:Bang.World.ActivateSystem(System.Type)">
            <summary>
            Activate a system of type <paramref name="t"/> within our world.
            </summary>
            <returns>
            Whether the system is found and has been activated.
            </returns>
        </member>
        <member name="M:Bang.World.DeactivateSystem``1">
            <summary>
            Deactivate a system within our world.
            </summary>
        </member>
        <member name="M:Bang.World.DeactivateSystem(System.Type)">
            <summary>
            Deactivate a system within our world.
            </summary>
        </member>
        <member name="M:Bang.World.Pause">
            <summary>
            Pause all the set of systems that qualify in <see cref="M:Bang.World.IsPauseSystem(Bang.Systems.ISystem)"/>.
            A paused system will no longer be called on any <see cref="M:Bang.World.Update"/> calls.
            </summary>
        </member>
        <member name="M:Bang.World.Resume">
            <summary>
            This will resume all paused systems.
            </summary>
        </member>
        <member name="M:Bang.World.ActivateSystem(System.Int32)">
            <summary>
            Activate a system within our world.
            </summary>
        </member>
        <member name="M:Bang.World.DeactivateSystem(System.Int32)">
            <summary>
            Deactivate a system within our world.
            </summary>
        </member>
        <member name="M:Bang.World.ActivateAllSystems">
            <summary>
            Activate all systems across the world.
            </summary>
            TODO: Optimize?
        </member>
        <member name="M:Bang.World.DeactivateAllSystems(System.Type[])">
            <summary>
            Deactivate all systems across the world.
            </summary>
            TODO: Optimize?
        </member>
        <member name="M:Bang.World.IsSystemOfType(Bang.Systems.ISystem,System.Type[])">
            <summary>
            Returns whether a system inherits from a given type.
            </summary>
        </member>
        <member name="M:Bang.World.GetUnique``1">
            <summary>
            Get the unique component within an entity <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Bang.World.TryGetUnique``1">
            <summary>
            Try to get a unique entity that owns <typeparamref name="T"/>.
            </summary>
            <returns>
            The unique component <typeparamref name="T"/>.
            </returns>
        </member>
        <member name="M:Bang.World.GetUniqueEntity``1">
            <summary>
            Get an entity with the unique component <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Bang.World.TryGetUniqueEntity``1">
            <summary>
            Try to get a unique entity that owns <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Bang.World.GetEntitiesWith(System.Type[])">
            <summary>
            Retrieve a context for the specified filter and components.
            </summary>
        </member>
        <member name="M:Bang.World.GetEntitiesWith(Bang.Contexts.ContextAccessorFilter,System.Type[])">
            <summary>
            Retrieve a context for the specified filter and components.
            </summary>
        </member>
        <member name="M:Bang.World.GetOrCreateContext(Bang.Contexts.ContextAccessorFilter,System.Int32[])">
            <summary>
            Get or create a context id for the specified filter and components.
            </summary>
        </member>
        <member name="M:Bang.World.Start">
            <summary>
            Call start on all systems.
            This is called before any updates and will notify any reactive systems by the end of it.
            </summary>
        </member>
        <member name="M:Bang.World.Exit">
            <summary>
            Call to end all systems.
            This is called right before shutting down or switching scenes.
            </summary>
        </member>
        <member name="M:Bang.World.Update">
            <summary>
            Calls update on all <see cref="T:Bang.Systems.IUpdateSystem"/> systems.
            At the end of update, it will notify all reactive systems of any changes made to entities
            they were watching.
            Finally, it destroys all pending entities and clear all messages.
            </summary>
        </member>
        <member name="M:Bang.World.FixedUpdate">
            <summary>
            Calls update on all <see cref="T:Bang.Systems.IFixedUpdateSystem"/> systems.
            This will be called on fixed intervals.
            </summary>
        </member>
        <member name="M:Bang.World.NotifyReactiveSystems">
            <summary>
            Notify all reactive systems of any change that happened during the update.
            </summary>
        </member>
        <member name="M:Bang.World.ClearMessages">
            <summary>
            This will clear any messages received by the entities within a frame.
            </summary>
        </member>
        <member name="M:Bang.World.OnMessage(Bang.Entities.Entity)">
            <summary>
            Notify that a message has been received for a <paramref name="entity"/>.
            </summary>
        </member>
        <member name="M:Bang.World.OnMessage(System.Int32,Bang.Entities.Entity,Bang.Components.IMessage)">
            <summary>
            Notify that a message has been received for a <paramref name="entity"/>.
            This will notify all systems immediately and clear the message at the end of the update.
            </summary>
        </member>
        <member name="F:Bang.World.UpdateCounters">
            <summary>
            This has the duration of each update system (id) to its corresponding time (in ms).
            See <see cref="F:Bang.World.IdToSystem"/> on how to fetch the actual system.
            </summary>
        </member>
        <member name="F:Bang.World.FixedUpdateCounters">
            <summary>
            This has the duration of each fixed update system (id) to its corresponding time (in ms).
            See <see cref="F:Bang.World.IdToSystem"/> on how to fetch the actual system.
            </summary>
        </member>
        <member name="F:Bang.World.ReactiveCounters">
            <summary>
            This has the duration of each reactive system (id) to its corresponding time (in ms).
            See <see cref="F:Bang.World.IdToSystem"/> on how to fetch the actual system.
            </summary>
        </member>
        <member name="M:Bang.World.InitializeDiagnosticsCounters">
            <summary>
            Initialize the performance counters according to the systems present in the world.
            </summary>
        </member>
        <member name="M:Bang.World.ClearDiagnosticsCountersForSystem(System.Int32)">
            <summary>
            Implemented by custom world in order to clear diagnostic information about the world.
            </summary>
            <param name="systemId"></param>
        </member>
        <member name="M:Bang.World.InitializeDiagnosticsForSystem(System.Int32,Bang.Systems.ISystem)">
            <summary>
            Implemented by custom world in order to express diagnostic information about the world.
            </summary>
        </member>
        <member name="M:Bang.World.FindLookupImplementation">
            <summary>
            Look for an implementation for the lookup table of components.
            </summary>
        </member>
        <member name="M:Bang.World.IsPauseSystem(Bang.Systems.ISystem)">
            <summary>
            Returns whether a system is eligible to be paused.
            This means that:
              - it is an update system;
              - it does not have the DoNotPauseAttribute.
            </summary>
        </member>
        <member name="M:Bang.World.IsPlayOnPauseSystem(Bang.Systems.ISystem)">
            <summary>
            Returns whether a system is only expect to play when the game is paused.
            This is useful when defining systems that still track the game stack, even if paused.
            </summary>
        </member>
    </members>
</doc>
