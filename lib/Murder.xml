<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Murder</name>
    </assembly>
    <members>
        <member name="F:Murder.Assets.CharacterAsset._situations">
            <summary>
            List of tasks or events that the <see cref="P:Murder.Assets.CharacterAsset.Situations"/> may do.
            </summary>
        </member>
        <member name="F:Murder.Assets.CharacterAsset._components">
            <summary>
            List of all the components that are modified within a dialog.
            </summary>
        </member>
        <member name="F:Murder.Assets.CharacterAsset._portraits">
            <summary>
            List of all the portraits that are modified within a dialog.
            </summary>
        </member>
        <member name="M:Murder.Assets.CharacterAsset.SetSituations(System.Collections.Generic.SortedList{System.Int32,Murder.Core.Dialogs.Situation})">
            <summary>
            Set the situation to a list. 
            This is called when updating the scripts with the latest data.
            </summary>
        </member>
        <member name="M:Murder.Assets.CharacterAsset.SetSituationAt(System.Int32,Murder.Core.Dialogs.Situation)">
            <summary>
            Set the situation on <paramref name="index"/> to <paramref name="situation"/>.
            </summary>
        </member>
        <member name="T:Murder.Assets.DynamicAsset">
            <summary>
            These are game assets that will be used in-game.
            TODO: Should dynamic objects have an attribute that point to the IComponent they replace...? Or not?
            E.g.: IComponent DynamicAsset.ProduceComponent()
            </summary>
        </member>
        <member name="F:Murder.Assets.FeatureAsset._systems">
            <summary>
            Map of all the systems and whether they are active or not.
            </summary>
        </member>
        <member name="F:Murder.Assets.GameAsset._nameSplit">
            Cache strings *
        </member>
        <member name="F:Murder.Assets.GameAsset._filePath">
            *
        </member>
        <member name="P:Murder.Assets.GameAsset.FilePath">
            <summary>
            Path to this asset file, relative to its base directory where this asset is stored.
            </summary>
        </member>
        <member name="P:Murder.Assets.GameAsset.Rename">
            <summary>
            Whether it should rename the file and delete the previous name.
            </summary>
        </member>
        <member name="P:Murder.Assets.GameAsset.IsStoredInSaveData">
            <summary>
            Whether this file is saved relative do the save path.
            </summary>
        </member>
        <member name="P:Murder.Assets.GameAsset.StoreInDatabase">
            <summary>
            Whether this file should be stored following a database hierarchy of the files.
            True by default.
            </summary>
        </member>
        <member name="M:Murder.Assets.GameAsset.Duplicate(System.String)">
            <summary>
            Create a duplicate of the current asset.
            </summary>
        </member>
        <member name="M:Murder.Assets.GameAsset.OnModified">
            <summary>
            Implemented by assets that may cache data.
            This notifies it that it has been modified (usually by an editor).
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.AtlasFolderName">
            <summary>
            Where our atlas .png and .json files are stored.
            Under: 
              packed/ -> bin/resources/
                atlas/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.ContentAsepritePath">
            <summary>
            Where our aseprite contents are stored.
            Under:
              packed/ -> bin/resources/
                aseprite/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.FontPath">
            <summary>
            Where our font contents are stored.
            Under:
              packed/ -> bin/resources/
                fonts/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.SoundsPath">
            <summary>
            Where our sound contents are stored.
            Under:
              packed/ -> bin/resources/
                sounds/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.DialoguesPath">
            <summary>
            Where our aseprite contents are stored.
            Under:
              packed/ -> bin/resources/
                dialogues/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.ShadersPath">
            <summary>
            Where our aseprite contents are stored.
            Under:
              packed/ -> bin/resources/
                shaders/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.HiResPath">
            <summary>
            Where our high resolution contents are stored.
            Under:
              packed/ -> bin/resources
                shaders/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.AssetResourcesPath">
            <summary>
            Root path where our data .json files are stored.
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.ContentECSPath">
            <summary>
            Where our ecs assets are stored.
            Under:
              resources/
                assets/
                  ecs/
            </summary>
        </member>
        <member name="F:Murder.Assets.GameProfile.GenericAssetsPath">
            <summary>
            Where our generic assets are stored.
            Under:
              resources/
                assets/
                  data/
            </summary>
        </member>
        <member name="M:Murder.Assets.Graphics.ParticleSystemAsset.CreateAt(Bang.World,Microsoft.Xna.Framework.Vector2,System.Boolean)">
            <summary>
            Create an instance of particle system.
            </summary>
        </member>
        <member name="F:Murder.Assets.Graphics.TilesetAsset.Order">
            <summary>
            This is the order (or layer) which this tileset will be drawn into the screen.
            </summary>
        </member>
        <member name="M:Murder.Assets.Graphics.TilesetAsset.CreatePreviewImage">
            <summary>
            Creates a new texture 2D from the graphics device.
            </summary>
        </member>
        <member name="T:Murder.Assets.IPreview">
            <summary>
            This is an interface implemented by assets which has a preview in the editor.
            </summary>
        </member>
        <member name="M:Murder.Assets.IPreview.GetPreviewId">
            <summary>
            Returns the preview id to show this image.
            </summary>
        </member>
        <member name="F:Murder.Assets.PrefabAsset.ShowOnPrefabSelector">
            <summary>
            Whether this should show in the editor selector.
            </summary>
        </member>
        <member name="F:Murder.Assets.PrefabAsset.Dimensions">
            <summary>
            Dimensions of the prefab. Used when drawing it on the map or the editor.
            </summary>
        </member>
        <member name="M:Murder.Assets.PrefabAsset.Create(Bang.World)">
            <summary>
            Create an instance of the entity and all of its children.
            </summary>
        </member>
        <member name="M:Murder.Assets.PrefabAsset.ToInstance(System.String)">
            <summary>
            Creates a new instance entity from the current asset.
            </summary>
        </member>
        <member name="M:Murder.Assets.PrefabAsset.AddChild(Murder.Prefabs.EntityInstance)">
            <summary>
            Add an entity asset as a children of the current asset.
            Each of the children will be an instance of the current asset.
            </summary>
        </member>
        <member name="M:Murder.Assets.PrefabAsset.RemoveChild(System.Guid)">
            <summary>
            Add an entity asset as a children of the current asset.
            Each of the children will be an instance of the current asset.
            </summary>
        </member>
        <member name="M:Murder.Assets.PrefabAsset.TryGetChild(System.Guid,Murder.Prefabs.EntityInstance@)">
            <summary>
            Retrieve a child for this asset.
            </summary>
        </member>
        <member name="M:Murder.Assets.PrefabAsset.GetChildrenModifiers">
            <summary>
            If this is based on a prefab reference, enable access to its children modifiers when creating entities in the world.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Murder.Assets.SaveData">
            <summary>
            Tracks a saved game with all the player status.
            </summary>
        </member>
        <member name="P:Murder.Assets.SaveData.SavedWorlds">
            <summary>
            This maps
             [World Guid -> Saved World Guid]
            that does not belong to a run and should be persisted.
            </summary>
        </member>
        <member name="F:Murder.Assets.SaveData._entitiesOnWorldToDestroy">
            <summary>
            List of all consumed entities throughout the map.
            Mapped according to:
            [World guid -> [Entity Guid]]
            </summary>
        </member>
        <member name="F:Murder.Assets.SaveData._lastWorld">
            <summary>
            This is the last world that the player was by the time this was saved.
            </summary>
        </member>
        <member name="P:Murder.Assets.SaveData.DynamicAssets">
            <summary>
            These are all the dynamic assets within the game session.
            </summary>
        </member>
        <member name="P:Murder.Assets.SaveData.SaveName">
            <summary>
            This is the name used in-game, specified by the user.
            </summary>
        </member>
        <member name="F:Murder.Assets.SaveData.SaveDataRelativeDirectoryPath">
            <summary>
            This is save path, used by its assets.
            </summary>
        </member>
        <member name="M:Murder.Assets.SaveData.TryLoadLevel(System.Guid)">
            <summary>
            Get a world asset to instantiate in the game.
            This tracks the <paramref name="guid"/> at <see cref="F:Murder.Assets.SaveData._lastWorld"/>.
            </summary>
        </member>
        <member name="M:Murder.Assets.SaveData.Save(Murder.Core.MonoWorld)">
            <summary>
            This saves a world that should be persisted across several runs.
            For now, this will be restricted to the city.
            </summary>
        </member>
        <member name="M:Murder.Assets.SaveData.ClearAllWorlds">
            <summary>
            This will clean all saved worlds.
            </summary>
        </member>
        <member name="M:Murder.Assets.SaveData.RecordRemovedEntityFromWorld(Bang.World,Bang.Entities.Entity)">
            <summary>
            This records that an entity has been removed from the map.
            </summary>
        </member>
        <member name="M:Murder.Assets.SaveData.GetOrCreateEntitiesToBeDestroyedAt(Bang.World)">
            <summary>
            Fetch the collected items at <paramref name="world"/>.
            If none, creates a new empty collection and returns that instead.
            </summary>
        </member>
        <member name="T:Murder.Assets.SavedWorld">
            <summary>
            Asset for a map that has been generated within a world.
            </summary>
        </member>
        <member name="F:Murder.Assets.WorldAsset.WorldName">
            <summary>
            This is the world name used when fetching this world within the game.
            </summary>
        </member>
        <member name="F:Murder.Assets.WorldAsset.Order">
            <summary>
            This is the order in which this world will be displayed in game (when selecting a lvel, etc.)
            </summary>
        </member>
        <member name="F:Murder.Assets.WorldAsset._systems">
            <summary>
            Map of all the systems and whether they are active or not.
            </summary>
        </member>
        <member name="F:Murder.Assets.WorldAsset._folders">
            <summary>
            These are the collection of entities grouped within a folder, distinguished by name.
            </summary>
        </member>
        <member name="M:Murder.Assets.WorldAsset.FetchFolders">
            <summary>
            This is for editor purposes, we group all entities in "folders" when visualizing them.
            This has no effect in the actual game.
            </summary>
        </member>
        <member name="F:Murder.Assets.WorldAsset._entitiesToFolder">
            <summary>
            Track each group that an entity belongs. Used for speeding up removing entities
            and moving them around.
            </summary>
        </member>
        <member name="M:Murder.Assets.WorldAsset.CreateAllEntities(Bang.World,System.Collections.Immutable.ImmutableArray{Murder.Prefabs.EntityInstance})">
            <summary>
            Create all entities into the world.
            </summary>
            <returns>
            Id of all the created entities.
            </returns>
        </member>
        <member name="M:Murder.Assets.WorldAsset.PostProcessEntities(Bang.World,System.Collections.Generic.Dictionary{System.Guid,System.Int32})">
            <summary>
            This makes any fancy post process once all entities were created in the world.
            This may trigger reactive components within the world.
            </summary>
            <param name="world">World that entities were created.</param>
            <param name="instancesToEntities">A map of each serialized guid to an entity id in the world.</param>
        </member>
        <member name="M:Murder.Assets.WorldAsset.ValidateInstances">
            <summary>
            Validate instances are remove any entities that no longer exist in the asset.
            </summary>
        </member>
        <member name="M:Murder.Assets.WorldAsset.AddGroup(System.String)">
            <summary>
            Add a new folder to group entities.
            </summary>
        </member>
        <member name="M:Murder.Assets.WorldAsset.DeleteGroup(System.String)">
            <summary>
            Delete a new folder to group entities.
            </summary>
        </member>
        <member name="M:Murder.Assets.WorldAsset.BelongsToAnyGroup(System.Guid)">
            <summary>
            Checks whether an entity belongs to any group.
            </summary>
        </member>
        <member name="M:Murder.Assets.WorldAsset.GetGroupOf(System.Guid)">
            <summary>
            Returns the group that an entity belongs.
            </summary>
        </member>
        <member name="F:Murder.Components.AgentComponent.Speed">
            <summary>
            Maximum speed of this agent
            </summary>
        </member>
        <member name="T:Murder.Components.DisableAgentComponent">
            <summary>
            Disables the agent from using the AgentMover and other agent related systems
            </summary>
        </member>
        <member name="M:Murder.Components.FacingComponent.#ctor(Murder.Helpers.Direction)">
            <summary>
            Creates a FacingComponent using a Direction as a base.
            </summary>
            <param name="direction"></param>
        </member>
        <member name="T:Murder.Components.IndestructibleComponent">
            <summary>
            Component used when an entity will no longer receive any
            damage from a hit.
            </summary>
        </member>
        <member name="T:Murder.Components.HAAStarPathfindComponent">
            <summary>
            This is a struct that points to a singleton class.
            Reactive systems won't be able to subscribe to this component.
            </summary>
        </member>
        <member name="F:Murder.Components.RouteComponent.Nodes">
            <summary>
            Nodes path that the agent will make.
            </summary>
        </member>
        <member name="F:Murder.Components.RouteComponent.Initial">
            <summary>
            Initial position cell.
            </summary>
        </member>
        <member name="F:Murder.Components.RouteComponent.Target">
            <summary>
            Goal position cell.
            </summary>
        </member>
        <member name="T:Murder.Components.CameraFollowComponent">
            <summary>
            Component used by the camera for tracking its target position.
            </summary>
        </member>
        <member name="F:Murder.Components.CameraFollowComponent.Style">
            <summary>
            Force to centralize the camera without a dead zone.
            </summary>
        </member>
        <member name="T:Murder.Components.CarveComponent">
            <summary>
            This is used for carve components within the map (that will not move a lot and 
            should be taken into account on pathfinding).
            This a tag used when caching information in <see cref="T:Murder.Core.Map"/>.
            </summary>
        </member>
        <member name="F:Murder.Components.CarveComponent.ClearPath">
            <summary>
            Whether this carve component will add a path if there was previously a collision in its area.
            For example, a bridge over a river.
            </summary>
        </member>
        <member name="F:Murder.Components.CarveComponent.Weight">
            <summary>
            Weight of the component, if not an obstacle.
            Ignored if <see cref="F:Murder.Components.CarveComponent.Obstacle"/> is true.
            </summary>
        </member>
        <member name="F:Murder.Components.ColliderComponent.Layer">
            <summary>
            Value of layer according to <see cref="T:Murder.Core.Physics.CollisionLayersBase"/>.
            </summary>
        </member>
        <member name="M:Murder.Components.ColliderComponent.SetLayer(System.Int32)">
            <summary>
            Set layer according to <see cref="T:Murder.Core.Physics.CollisionLayersBase"/>.
            </summary>
        </member>
        <member name="T:Murder.Components.Cutscenes.CutsceneAnchorsComponent">
            <summary>
            This is a list of anchor points of cutscene.
            </summary>
        </member>
        <member name="T:Murder.Components.RuleWatcherComponent">
            <summary>
            This will watch for rule changes based on the blackboard system.
            </summary>
        </member>
        <member name="F:Murder.Components.SituationComponent.Situation">
            <summary>
            This is the starter situation for the interaction.
            </summary>
        </member>
        <member name="T:Murder.Components.SpeakerComponent">
            <summary>
            Component for an entity that is able to speak with other elements.
            </summary>
        </member>
        <member name="T:Murder.Components.AlphaComponent">
            <summary>
            Set alpha of a component being displayed in the screen.
            </summary>
        </member>
        <member name="T:Murder.Components.Effects.DisableEntityComponent">
            <summary>
            Component that temporarily excludes this entity to exist within the world.
            </summary>
        </member>
        <member name="M:Murder.Components.FadeScreenComponent.#ctor(Murder.Components.FadeType,System.Single,System.Single,Murder.Core.Graphics.Color,System.Boolean,System.String)">
            <summary>
            Fades the screen using the FadeScreenSystem
            </summary>
        </member>
        <member name="T:Murder.Components.FadeTransitionComponent">
            <summary>
            For now, this will only fade out aseprite components.
            </summary>
        </member>
        <member name="F:Murder.Components.FadeTransitionComponent.Duration">
            <summary>
            Fade duration in seconds.
            </summary>
        </member>
        <member name="T:Murder.Components.FadeWhenInAreaComponent">
            <summary>
            For now, this is only supported for aseprite components.
            </summary>
        </member>
        <member name="T:Murder.Components.RequiresVisionComponent">
            <summary>
            Will only be rendered if the player has vision on this
            </summary>
        </member>
        <member name="F:Murder.Components.RotateComponent.Rotation">
            <summary>
            In radians.
            </summary>
        </member>
        <member name="T:Murder.Components.EntityTrackerComponent">
            <summary>
            This is a component used to track other entities within the world.
            action.
            </summary>
        </member>
        <member name="F:Murder.Components.EntityTrackerComponent.Target">
            <summary>
            Id of the target entity.
            </summary>
        </member>
        <member name="T:Murder.Components.FloatRange">
            <summary>
            Range of float values.
            </summary>
        </member>
        <member name="T:Murder.Components.AnimationCompleteComponent">
            <summary>
            The Aseprite component in this entity completed it's animation
            </summary>
        </member>
        <member name="T:Murder.Components.AnimationSpeedOverload">
            <summary>
            Makes that the animation plays at a different rate.
            </summary>
        </member>
        <member name="F:Murder.Components.SpriteComponent.AnimationGuid">
            <summary>
            The Guid of the Aseprite file.
            </summary>
        </member>
        <member name="P:Murder.Components.SpriteComponent.CurrentAnimation">
            <summary>
            Current playing animation id.
            </summary>
        </member>
        <member name="F:Murder.Components.Graphics.ParallaxComponent.Factor">
            <summary>
            How much parallax this entity has. 0 never moves, 1 moves normaly and more than 1 is the foreground.
            </summary>
        </member>
        <member name="T:Murder.Components.Graphics.ThreeSliceComponent">
            <summary>
            This component makes sure that any aseprite will render as a 3-slice instead,
            as specified.
            </summary>
        </member>
        <member name="T:Murder.Components.ParticleSystemWorldTrackerComponent">
            <summary>
            This tracks all the particle systems that are currently active in the world.
            </summary>
        </member>
        <member name="T:Murder.Components.PauseAnimationComponent">
            <summary>
            Struct to describe an entity that will not never have its animation paused.
            </summary>
        </member>
        <member name="T:Murder.Components.MapComponent">
            <summary>
            This is a struct that points to a singleton class.
            Reactive systems won't be able to subscribe to this component.
            </summary>
        </member>
        <member name="T:Murder.Components.RoomComponent">
            <summary>
            This describes a room component properties.
            </summary>
        </member>
        <member name="T:Murder.Components.TileGridComponent">
            <summary>
            This is a struct that points to a singleton class.
            Reactive systems won't be able to subscribe to this component.
            </summary>
        </member>
        <member name="T:Murder.Components.TilesetComponent">
            <summary>
            This is a struct that points to a singleton class.
            Reactive systems won't be able to subscribe to this component.
            </summary>
        </member>
        <member name="F:Murder.Components.CollisionCacheComponent._collidingWith">
            <summary>
            Id of the entity that caused this collision.
            </summary>
        </member>
        <member name="F:Murder.Components.InteractOnRuleMatchCollectionComponent.Requirements">
            <summary>
            List of interactions that will be triggered.
            </summary>
        </member>
        <member name="F:Murder.Components.AfterInteractRule.InteractOnReload">
            <summary>
            Instead of removing this component once triggered, this will only disable it.
            </summary>
        </member>
        <member name="F:Murder.Components.AfterInteractRule.RemoveEntity">
            <summary>
            Instead of removing this component once triggered, this will remove the entity.
            </summary>
        </member>
        <member name="F:Murder.Components.AfterInteractRule.AlwaysInteract">
            <summary>
            Always interact whenever this gets triggered.
            </summary>
        </member>
        <member name="F:Murder.Components.InteractOnRuleMatchComponent.Triggered">
            <summary>
            This will only be triggered once the component has been interacted with.
            Used if <see cref="F:Murder.Components.AfterInteractRule.InteractOnReload"/> is set.
            </summary>
        </member>
        <member name="F:Murder.Components.InteractOnRuleMatchComponent.Requirements">
            <summary>
            List of requirements which will trigger the interactive component within the same entity.
            </summary>
        </member>
        <member name="T:Murder.Components.PickEntityToAddOnStartComponent">
            <summary>
            This will trigger an effect by placing <see cref="F:Murder.Components.PickEntityToAddOnStartComponent.OnMatchPrefab"/> or <see cref="F:Murder.Components.PickEntityToAddOnStartComponent.OnNotMatchPrefab"/> in the world.
            </summary>
        </member>
        <member name="T:Murder.Components.RemoveEntityOnRuleMatchAtLoadComponent">
            <summary>
            This will remove the entity that contains this component as soon as the entity is serialized
            into an actual world instance.
            </summary>
        </member>
        <member name="F:Murder.Components.RemoveEntityOnRuleMatchAtLoadComponent.Requirements">
            <summary>
            List of requirements which will trigger the interactive component within the same entity.
            </summary>
        </member>
        <member name="T:Murder.Components.IgnoreTriggersUntilComponent">
            <summary>
            Ignores all trigger collisions until a time is reached, then it gets removed
            </summary>
        </member>
        <member name="T:Murder.Components.MoveToPerfectComponent">
            <summary>
            This is a move to component that is not tied to any agent and
            that matches perfectly the target.
            </summary>
        </member>
        <member name="T:Murder.Components.GuidToIdTargetCollectionComponent">
            <summary>
            This is a component used to translate entity instaces guid to an actual entity id.
            </summary>
            
        </member>
        <member name="F:Murder.Components.GuidToIdTargetCollectionComponent.Targets">
            <summary>
            Guid of the target entity.
            </summary>
        </member>
        <member name="T:Murder.Components.GuidToIdTargetComponent">
            <summary>
            This is a component used to translate entity instaces guid to an actual entity id.
            Gets translated to <see cref="T:Murder.Components.IdTargetComponent"/>.
            </summary>
            
        </member>
        <member name="F:Murder.Components.GuidToIdTargetComponent.Target">
            <summary>
            Guid of the target entity.
            </summary>
        </member>
        <member name="T:Murder.Components.IdTargetCollectionComponent">
            <summary>
            This is a component with a collection of entities tracked in the world.
            </summary>
        </member>
        <member name="F:Murder.Components.IdTargetCollectionComponent.Targets">
            <summary>
            Id of the target entity.
            </summary>
        </member>
        <member name="T:Murder.Components.IdTargetComponent">
            <summary>
            This is a component used to track other entities when triggering an interaction or other
            action.
            </summary>
        </member>
        <member name="F:Murder.Components.IdTargetComponent.Target">
            <summary>
            Id of the target entity.
            </summary>
        </member>
        <member name="T:Murder.Components.InstanceToEntityLookupComponent">
            <summary>
            This is used when serializing save data. This keeps a reference between entities and their guid.
            </summary>
        </member>
        <member name="F:Murder.Components.InstanceToEntityLookupComponent.InstancesToEntities">
            <summary>
            This keeps a map of the instances (guid) to their entities (id).
            </summary>
        </member>
        <member name="F:Murder.Components.InstanceToEntityLookupComponent.EntitiesToInstances">
            <summary>
            This keeps a map of the instances (guid) to their entities (id).
            </summary>
        </member>
        <member name="T:Murder.Components.MusicComponent">
            <summary>
            Music component which will be immediately played and destroyed.
            </summary>
        </member>
        <member name="T:Murder.Components.SoundComponent">
            <summary>
            Sound component which will be immediately played and destroyed.
            </summary>
        </member>
        <member name="T:Murder.Components.IMurderTransformComponent">
            <summary>
            This is an interface for transform components within the game.
            </summary>
        </member>
        <member name="P:Murder.Components.IMurderTransformComponent.X">
            <summary>
            Relative X position of the component.
            </summary>
        </member>
        <member name="P:Murder.Components.IMurderTransformComponent.Y">
            <summary>
            Relative Y position of the component.
            </summary>
        </member>
        <member name="P:Murder.Components.IMurderTransformComponent.Cx">
            <summary>
            This is the X grid coordinate. See <see cref="T:Murder.Core.Grid"/> for more details on our grid specs.
            </summary>
        </member>
        <member name="P:Murder.Components.IMurderTransformComponent.Cy">
            <summary>
            This is the Y grid coordinate. See <see cref="T:Murder.Core.Grid"/> for more details on our grid specs.
            </summary>
        </member>
        <member name="T:Murder.Components.PositionComponent">
            <summary>
            Position component used to track entities positions within a grid.
            </summary>
        </member>
        <member name="P:Murder.Components.PositionComponent.X">
            <summary>
            Relative X position of the component.
            </summary>
        </member>
        <member name="P:Murder.Components.PositionComponent.Y">
            <summary>
            Relative Y position of the component.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionComponent.GetGlobal">
            <summary>
            Return the global position of the component within the world.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionComponent.#ctor(System.Single,System.Single,Murder.Components.IMurderTransformComponent)">
            <summary>
            Create a new <see cref="T:Murder.Components.PositionComponent"/>.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionComponent.#ctor(Murder.Core.Geometry.Vector2)">
            <summary>
            Create a new <see cref="T:Murder.Components.PositionComponent"/>.
            </summary>
            <param name="v">Vector coordinate.</param>
        </member>
        <member name="M:Murder.Components.PositionComponent.#ctor(Murder.Core.Geometry.Point)">
            <summary>
            Create a new <see cref="T:Murder.Components.PositionComponent"/>.
            </summary>
            <param name="p">Point coordinate.</param>
        </member>
        <member name="M:Murder.Components.PositionComponent.WithoutParent">
            <summary>
            Creates a copy of component with the relative coordinates without its parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Murder.Components.PositionComponent.HasParent">
            <summary>
            Whether this position is tracking a parent entity.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionComponent.OnParentModified(Bang.Components.IComponent,Bang.Entities.Entity)">
            <summary>
            This tracks whenever a parent position has been modified.
            </summary>
            <param name="parentComponent">The parent position component.</param>
            <param name="childEntity">The entity of the child which owns this component.</param>
        </member>
        <member name="M:Murder.Components.PositionComponent.Equals(Murder.Components.PositionComponent)">
            <summary>
            Compares two position components. This will take their parents into account.
            </summary>
        </member>
        <member name="T:Murder.Components.PositionRotationComponent">
            <summary>
            Position component used to track entities positions within a grid.
            </summary>
        </member>
        <member name="P:Murder.Components.PositionRotationComponent.X">
            <summary>
            Relative X position of the component.
            </summary>
        </member>
        <member name="P:Murder.Components.PositionRotationComponent.Y">
            <summary>
            Relative Y position of the component.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.#ctor(System.Single,System.Single,System.Single,Murder.Components.IMurderTransformComponent)">
            <summary>
            Create a new <see cref="T:Murder.Components.PositionRotationComponent"/>.
            </summary>
            <param name="x">Position x within the world.</param>
            <param name="y">Position y within the world.</param>
            <param name="angle">In degrees.</param>
            <param name="parent">Optional parent component.</param>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.#ctor(Murder.Core.Geometry.Vector2,System.Single)">
            <summary>
            Create a new <see cref="T:Murder.Components.PositionRotationComponent"/>.
            </summary>
            <param name="v">Vector coordinate.</param>
            <param name="angle">In degrees</param>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.#ctor(Murder.Core.Geometry.Point,System.Single)">
            <summary>
            Create a new <see cref="T:Murder.Components.PositionRotationComponent"/>.
            </summary>
            <param name="p">Point coordinate.</param>
            <param name="angle"></param>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.GetGlobal">
            <summary>
            Return the global position of the component within the world.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.WithoutParent">
            <summary>
            Creates a copy of component with the relative coordinates without its parent.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Murder.Components.PositionRotationComponent.HasParent">
            <summary>
            Whether this position is tracking a parent entity.
            </summary>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.OnParentModified(Bang.Components.IComponent,Bang.Entities.Entity)">
            <summary>
            This tracks whenever a parent position has been modified.
            </summary>
            <param name="parentComponent">The parent position component.</param>
            <param name="childEntity">The entity of the child which owns this component.</param>
        </member>
        <member name="M:Murder.Components.PositionRotationComponent.Equals(Murder.Components.PositionRotationComponent)">
            <summary>
            Compares two position components. This will take their parents into account.
            </summary>
        </member>
        <member name="T:Murder.Components.WindowRefreshTrackerComponent">
            <summary>
            This will watch for rule changes based on the blackboard system.
            </summary>
        </member>
        <member name="F:Murder.Components.DestroyOnBlackboardConditionComponent.Rules">
            <summary>
            List of requirements for destroying this object.
            </summary>
        </member>
        <member name="M:Murder.Components.DestroyAtTimeComponent.#ctor">
            <summary>
            Destroy at the end of the frame
            </summary>
        </member>
        <member name="M:Murder.Core.Ai.PathfindServices.FindPath(Murder.Core.Map,Bang.World,Murder.Core.Geometry.Point,Murder.Core.Geometry.Point,Murder.Core.Ai.PathfindAlgorithmKind)">
            <summary>
            Find a path between <paramref name="initial"/> and <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Ai.PathfindServices.UpdatePathfind(Bang.World)">
            <summary>
            Update all cached pathfind on a map change.
            </summary>
            <param name="world"></param>
        </member>
        <member name="M:Murder.Core.Ai.PathfindServices.NeighboursWithoutCollision(Murder.Core.Geometry.Point,Murder.Core.Map)">
            <summary>
            Returns all the neighbours of a position within a collision map.
            </summary>
        </member>
        <member name="T:Murder.Core.Dialogs.BaseCharacterBlackboard">
            <summary>
            Built-in capabilities for each speaker blackboard.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.BaseCharacterBlackboard.TotalInteractions">
            <summary>
            Total of times that it has been interacted to.
            </summary>
        </member>
        <member name="T:Murder.Core.Dialogs.IBlackboard">
            <summary>
            This is a blackboard tracker with dialog variables.
            This is used when defining the set of conditions which will play a given dialog.
            </summary>
        </member>
        <member name="T:Murder.Core.Dialogs.ICharacterBlackboard">
            <summary>
            This works similarly as a <see cref="T:Murder.Core.Dialogs.IBlackboard"/>, except that each situation
            on the game has its own table.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Character._guid">
            <summary>
            The guid of the character asset being tracked by this.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Character._speaker">
            <summary>
            The speaker is the owner of this dialog. Used when a null
            speaker is found.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Character.Situations">
            <summary>
            All situations for the character.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Character._currentSituation">
            <summary>
            This is the current situation that the charcterr is currently executing.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Character._currentDialog">
            <summary>
            This is the dialog within the situation that is currently active.
            This is zero if it hasn't started yet.
            This is null if the situation has no more viable states.
            Not persisted.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Character._activeLine">
            <summary>
            Active line in the current dialog.
            Not persisted.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.HasNext(Bang.World,Bang.Entities.Entity)">
            <summary>
            Returns whether the active dialog state for this dialogue is valid or not.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.TrackInteracted">
            <summary>
            Track the character blackboard that an interaction has occurred.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.TryMatchNextDialog(Bang.World,Bang.Entities.Entity)">
            <summary>
            This looks for the next dialog most eligible to be triggered.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.ChooseBestScoreDialog(Bang.World,Bang.Entities.Entity,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Returns the dialog with the highest score in <paramref name="candidates"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.ChooseNextDialog(Bang.World,Bang.Entities.Entity,System.Collections.Generic.IList{System.Int32})">
            <summary>
            Returns the first dialog that matches in <paramref name="candidates"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.ChooseRandomDialog(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Returns a random dialog in <paramref name="candidates"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Character.CreateEntityForAction(Bang.World,Bang.Entities.Entity)">
            <summary>
            When a dialog creates an entity, we propagate the relevant target values.
            </summary>
            <param name="world">Current world that the entity will be added.</param>
            <param name="target">Entity that originally triggered the action.</param>
        </member>
        <member name="P:Murder.Core.Dialogs.Criterion.Weight">
            <summary>
            Creates a fact of type <see cref="F:Murder.Core.Dialogs.FactKind.Weight"/>.
            </summary>
        </member>
        <member name="P:Murder.Core.Dialogs.Criterion.Component">
            <summary>
            Creates a fact of type <see cref="F:Murder.Core.Dialogs.FactKind.Component"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Criterion.FetchValidCriteriaKind">
            <summary>
            This returns a list of all the valid criteria kind for the fact.
            </summary>
            <returns></returns>
        </member>
        <member name="F:Murder.Core.Dialogs.Dialog.PlayUntil">
            <summary>
            Stop playing this dialog until this number.
            If -1, this will play forever.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Dialog.GoTo">
            <summary>
            Go to another dialog with a specified id.
            </summary>
        </member>
        <member name="T:Murder.Core.Dialogs.DialogItemId">
            <summary>
            This represents an item in the dialog that has been manually modified by the user
            and should be persisted.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.FactKind.Weight">
            <summary>
            Used when the fact is only a weight which will be applied when picking
            the most suitable dialog.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.FactKind.Component">
            <summary>
            Used when checking for required components.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Fact.Blackboard">
            <summary>
            If null, grab the default blackboard.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Fact.ComponentType">
            <summary>
            Set when the fact is of type <see cref="F:Murder.Core.Dialogs.FactKind.Component"/>
            </summary>
        </member>
        <member name="P:Murder.Core.Dialogs.Fact.Weight">
            <summary>
            Creates a fact of type <see cref="F:Murder.Core.Dialogs.FactKind.Weight"/>.
            </summary>
        </member>
        <member name="P:Murder.Core.Dialogs.Fact.Component">
            <summary>
            Creates a fact of type <see cref="F:Murder.Core.Dialogs.FactKind.Component"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.ChoiceLine.Title">
            <summary>
            Dialog title.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.ChoiceLine.Choices">
            <summary>
            Choices available to the player to pick.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Line.Text">
            <summary>
            If the caption has a text, this will be the information.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.Line.Delay">
            <summary>
            Delay in seconds.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Line.#ctor(System.String)">
            <summary>
            Create a line with a text without any speaker.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Line.#ctor(System.Guid,System.String)">
            <summary>
            Create a line with a text. That won't be used as a timer.
            </summary>
        </member>
        <member name="M:Murder.Core.Dialogs.Line.#ctor(System.Nullable{System.Guid},System.Single)">
            <summary>
            Create a line with a delay. That won't be used as a text.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.MatchKind.Next">
            <summary>
            This will pick in consecutive order, whatever matches first.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.MatchKind.Random">
            <summary>
            This will pick random dialogs.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.MatchKind.HighestScore">
            <summary>
            This will pick the dialog with the highest score.
            This is when dialogs are listed with -/+.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.MatchKind.IfElse">
            <summary>
            All the blocks that are next are subjected to an "else" relationship.
            </summary>
        </member>
        <member name="F:Murder.Core.Dialogs.MatchKind.Choice">
            <summary>
            Choice dialogs (>) that the player can pick.
            </summary>
        </member>
        <member name="T:Murder.Core.Graphics.IGuiSystem">
            <summary>
            System for rendering Gui entities.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.IGuiSystem.DrawGui(Murder.Core.Graphics.RenderContext,Bang.Contexts.Context)">
            <summary>
            Called before rendering starts.
            </summary>
        </member>
        <member name="T:Murder.Core.Graphics.IMonoPreRenderSystem">
            <summary>
            System called right before rendering.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.IMonoPreRenderSystem.BeforeDraw(Bang.Contexts.Context)">
            <summary>
            Called before rendering starts.
            This gets called before the SpriteBatch.Begin() and SpriteBatch.End() starts.
            </summary>
        </member>
        <member name="T:Murder.Core.Graphics.IMonoRenderSystem">
            <summary>
            Main render system. This is used to draw on the screen and should not 
            have any update logic.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.IMonoRenderSystem.Draw(Murder.Core.Graphics.RenderContext,Bang.Contexts.Context)">
            <summary>
            Called on rendering.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.Animation.Evaluate(System.Single,System.Single)">
            <param name="startTime">Time when the animation first played</param>
            <param name="currentTime">Current game time</param>
            <returns>The name of the current frame</returns>
        </member>
        <member name="T:Murder.Core.Graphics.AtlasCoordinates">
            <summary>
            An image coordinate inside an atlas
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.AtlasCoordinates.Draw(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,System.Single,Murder.Core.Graphics.ImageFlip,Murder.Core.Graphics.Color,Microsoft.Xna.Framework.Vector3,System.Single)">
            <summary>
            Draws an image stored inside an atlas to the spritebatch.
            </summary>
            <param name="spriteBatch">The target <see cref="T:Murder.Core.Graphics.Batch2D"/></param>
            <param name="position">The pixel position to draw inside the <see cref="T:Murder.Core.Graphics.Batch2D"/></param>
            <param name="scale">The scale of the image (1 is the actual size).</param>
            <param name="origin">The pixel coordinate of the scale and rotation origin.</param>
            <param name="rotation">The rotation of the sprite, in radinans.</param>
            <param name="color">The color tint (or fill) to be applied to the image. The alpha is also applied to the image for transparency.</param>
            <param name="flip">If the image should be flipped horizontally, vertically, both or neither.</param>
            <param name="blendStyle">The blend style to be used by the shader. Use the constants in <see cref="T:Murder.Services.RenderServices"/>.</param>
            <param name="depthLayer">A number from 0 to 1 that will be used to sort the images. 1 is behind, 0 is in front.</param>
        </member>
        <member name="M:Murder.Core.Graphics.AtlasCoordinates.Draw(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Rectangle,Murder.Core.Graphics.Color,System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
             Draws a partial image stored inside an atlas to the spritebatch.
            </summary>
            <param name="spriteBatch"></param>
            <param name="position"></param>
            <param name="clip"></param>
            <param name="color"></param>
            <param name="depthLayer"></param>
            <param name="blend"></param>
        </member>
        <member name="M:Murder.Core.Graphics.AtlasCoordinates.Draw(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Rectangle,Murder.Core.Geometry.Rectangle,Murder.Core.Graphics.Color,System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
             Draws a partial image stored inside an atlas to the spritebatch to a specific rect
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.AtlasCoordinates.Draw(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,System.Single)">
            <summary>
            Simpler draw method, just draws the image to the screen at a position. No fancy business.
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.Batch2D.TotalDrawCalls">
            <summary>
            Track number of draw calls.
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.Batch2D.SpriteCount">
            <summary>
            Sprite count at current buffer.
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.Batch2D.AutoHandleAlphaBlendedSprites">
            <summary>
            Auto handle any non-opaque (i.e. with some transparency; Opacity &lt; 1.0f) sprite rendering.
            By drawing first all opaque sprites, with depth write enabled, followed by non-opaque sprites, with only depth read enabled.
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.Batch2D.BatchMode">
            Initialized in Begin() *
        </member>
        <member name="M:Murder.Core.Graphics.Batch2D.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Rectangle,System.Single,System.Single,Microsoft.Xna.Framework.Vector2,Murder.Core.Graphics.ImageFlip,Microsoft.Xna.Framework.Color,Microsoft.Xna.Framework.Vector2,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Draw a sprite to this sprite batch.
            </summary>
            <param name="texture">Texture to be drawn.</param>
            <param name="position">Position in the spritebatch (before camera).</param>
            <param name="targetSize">The pixel size of the texture to be drawn, before scaling.</param>
            <param name="sourceRectangle">The area of the original image to draw.</param>
            <param name="rotation">Rotation of the image, from the origin point, in radians.</param>
            <param name="scale">The scale applied to the image from the origin point. 1 is the actual scale.</param>
            <param name="flip">If the image should be flipped horizontally, vertically, both or neither.</param>
            <param name="color">The color tint (or fill) to be applied to the image. The alpha is also applied to the image for transparency.</param>
            <param name="origin">The origin point for scaling and rotating.</param>
            <param name="blendStyle">The blend style to be used by the shader. Use the constants in <see cref="T:Murder.Services.RenderServices"/>.</param>
            <param name="sort">A number from 0 to 1 that will be used to sort the images. 0 is behind, 1 is in front.</param>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:Murder.Core.Graphics.Batch2D.Dispose">
            <summary>
            Immediately releases the unmanaged resources used by this object.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.Batch2D.Flush(System.Boolean)">
            <summary>
            Send all stored batches to rendering, but doesn't end batching.
            If auto handle alpha blended sprites is active, be careful! Since it can includes alpha blended sprites too.
            </summary>
            <param name="includeAlphaBlendedSprites">True, if flush can include stored alpha blended sprites (possibly breaking rendering order, unless you know what are doing), otherwise False.</param>
        </member>
        <member name="T:Murder.Core.Graphics.BatchMode">
            <summary>
            How SpriteBatch rendering should behave.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.BatchMode.DrawOrder">
            <summary>
            Standard way. Will respect SpriteBatch.Draw*() call order, ignoring Layer Depth, but still trying to group as many batches as possible to reduce draw calls.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.BatchMode.DepthSortAscending">
            <summary>
            Sort batches by Layer Depth using ascending order, but still trying to group as many batches as possible to reduce draw calls.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.BatchMode.DepthSortDescending">
            <summary>
            Sort batches by Layer Depth using descending order, but still trying to group as many batches as possible to reduce draw calls.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.BatchMode.Immediate">
            <summary>
            Every SpriteBatch.Draw*() will result in an isolate draw call. No batching will be made, so be careful.
            </summary>
        </member>
        <member name="T:Murder.Core.Graphics.BloomFilter">
            <summary>
            
            https://github.com/Kosmonaut3d/BloomFilter-for-Monogame-and-XNA
            Version 1.1, 16. Dez. 2016
            
            Bloom / Blur, 2016 TheKosmonaut
            
            High-Quality Bloom filter for high-performance applications
            Based largely on the implementations in Unreal Engine 4 and Call of Duty AW
            For more information look for
            "Next Generation Post Processing in Call of Duty Advanced Warfare" by Jorge Jimenez
            http://www.iryoku.com/downloads/Next-Generation-Post-Processing-in-Call-of-Duty-Advanced-Warfare-v18.pptx
            
            The idea is to have several rendertargets or one rendertarget with several mip maps
            so each mip has half resolution (1/2 width and 1/2 height) of the previous one.
            
            32, 16, 8, 4, 2
            
            In the first step we extract the bright spots from the original image. If not specified otherwise thsi happens in full resolution.
            We can do that based on the average RGB value or Luminance and check whether this value is higher than our Threshold.
                BloomUseLuminance = true / false (default is true)
                BloomThreshold = 0.8f;
            
            Then we downscale this extraction layer to the next mip map.
            While doing that we sample several pixels around the origin.
            We continue to downsample a few more times, defined in
                BloomDownsamplePasses = 5 ( default is 5)
            
            Afterwards we upsample again, but blur in this step, too.
            The final output should be a blur with a very large kernel and smooth gradient.
            
            The output in the draw is only the blurred extracted texture. 
            It can be drawn on top of / merged with the original image with an additive operation for example.
            
            If you use ToneMapping you should apply Bloom before that step.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.BloomFilter.#ctor(Microsoft.Xna.Framework.Graphics.GraphicsDevice,Microsoft.Xna.Framework.Graphics.Effect,System.Int32,System.Int32,Microsoft.Xna.Framework.Graphics.SurfaceFormat,Murder.Core.Graphics.QuadRenderer)">
            <summary>
            Initialize and load all needed components for the BloomEffect.
            </summary>
            <param name="graphicsDevice">Graphics device used in the game.</param>
            <param name="bloomEffect">Bloom effect.</param>
            <param name="width">initial value for creating the rendertargets</param>
            <param name="height">initial value for creating the rendertargets</param>
            <param name="renderTargetFormat">The intended format for the rendertargets. For normal, non-hdr, applications color or rgba1010102 are fine NOTE: For OpenGL, SurfaceFormat.Color is recommended for non-HDR applications.</param>
            <param name="quadRenderer">if you already have quadRenderer you may reuse it here</param>
        </member>
        <member name="M:Murder.Core.Graphics.BloomFilter.SetBloomPreset(Murder.Core.Graphics.BloomFilter.BloomPresets)">
            <summary>
            A few presets with different values for the different mip levels of our bloom.
            </summary>
            <param name="preset">See BloomPresets enums. Example: BloomPresets.Wide</param>
        </member>
        <member name="M:Murder.Core.Graphics.BloomFilter.Draw(Microsoft.Xna.Framework.Graphics.Texture2D,System.Int32,System.Int32)">
            <summary>
            Main draw function
            </summary>
            <param name="inputTexture">the image from which we want to extract bright parts and blur these</param>
            <param name="width">width of our target. If different to the input.Texture width our final texture will be smaller/larger.
            For example we can use half resolution. Input: 1280px wide -> width = 640px
            The smaller this value the better performance and the worse our final image quality</param>
            <param name="height">see: width</param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Graphics.BloomFilter.UpdateResolution(System.Int32,System.Int32)">
            <summary>
            Update the InverseResolution of the used rendertargets. This should be the InverseResolution of the processed image
            We use SurfaceFormat.Color, but you can use higher precision buffers obviously.
            </summary>
            <param name="width">width of the image</param>
            <param name="height">height of the image</param>
        </member>
        <member name="M:Murder.Core.Graphics.BloomFilter.Dispose">
             <summary>
            Dispose our RenderTargets. This is not covered by the Garbage Collector so we have to do it manually
             </summary>
        </member>
        <member name="T:Murder.Core.Graphics.Camera2D">
            <summary>
            Creates a camera 2D world view for our game.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.Camera2D._rotation">
            <summary>
            The rotation of the camera in degrees.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.Camera2D.GetCursorWorldPosition(Murder.Core.Geometry.Point,Murder.Core.Geometry.Point)">
            <summary>
            Get coordinates of the cursor in the world.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.Camera2D.ConvertWorldToScreenPosition(Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Point)">
            <summary>
            Get coordinates of the cursor in the world.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.Color.FromHex(System.String)">
            <summary>
            Parses a string <paramref name="hex"/> to <see cref="T:Murder.Core.Graphics.Color"/>.
            </summary>
            <param name="hex">The string as the hex value, e.g. "#ff5545". Alpha will always be 1.</param>
            <returns>The converted color.</returns>
        </member>
        <member name="T:Murder.Core.Graphics.DrawInfo">
            <summary>
            Generic struct for drawing things without cluttering methods full of arguments.
            Note that not all fields are supported by all methods.
            Tip: Create a new one like this: <code>new DrawInfo(){ Color = Color.Red, Sort = 0.2f}</code>
            </summary> 
        </member>
        <member name="P:Murder.Core.Graphics.DrawInfo.Origin">
            <summary>
            The origin of the image. From 0 to 1. Vector2.Center is the center.
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.DrawInfo.Offset">
            <summary>
            An offset to draw this image. In pixels
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.DrawInfo.UseScaledTime">
            <summary>
            If this is an animation, will it use scaled time?
            </summary>
        </member>
        <member name="P:Murder.Core.Graphics.DrawInfo.Rotation">
            <summary>
            In degrees.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.MurderTexture.Draw(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Rectangle,Murder.Core.Graphics.Color,Murder.Core.Graphics.ImageFlip,System.Single,Microsoft.Xna.Framework.Vector3)">
            <summary>
            Draws a texture with a clipping area.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.PixelFontSize.Draw(System.String,Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,System.Single,System.Int32,System.Single,Murder.Core.Graphics.Color,System.Nullable{Murder.Core.Graphics.Color},System.Nullable{Murder.Core.Graphics.Color},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Draw a text with pixel font. If <paramref name="maxWidth"/> is specified, this will automatically wrap the text.
            </summary>
            <returns>Total lines drawn.</returns>
        </member>
        <member name="T:Murder.Core.Graphics.QuadRenderer">
            <summary>
            Renders a simple quad to the screen. Uncomment the Vertex / Index buffers to make it a static fullscreen quad. 
            The performance effect is barely measurable though and you need to dispose of the buffers when finished!
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.RenderContext._tempTarget">
            <summary>
            Temporary buffer with the camera size. Used so we can apply effects
            such as limited palette and bloom on a smaller screen before applying
            it to the final target
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.RenderContext._finalTarget">
            <summary>
            The final screen target, has the real screen size.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.RenderContext._bloomBrightRenderTarget">
            <summary>
            Bloom temporary render target (for bright pass)
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.RenderContext._bloomBlurRenderTarget">
            <summary>
            Bloom temporary render target (for blur pass)
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.RenderContext.RefreshWindow(Murder.Core.Geometry.Point,System.Single)">
            <summary>
            Refresh the window size with <paramref name="size"/> with width and height information,
            respectively.
            </summary>
            <returns>
            Whether the window actually required a refresh.
            </returns>
        </member>
        <member name="M:Murder.Core.Graphics.RenderContext.Unload">
            <summary>
            Unload the render context.
            Called when the render context is no longer being actively displayed.
            </summary>
        </member>
        <member name="T:Murder.Core.Graphics.SharedResources">
            <summary>
            Shared resources used per game instance.
            TODO: Move to RenderContext?
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.SharedResources._pixel">
            Textures 2D do not need to be created for each spritebatch, only for different graphics devices.
        </member>
        <member name="T:Murder.Core.Graphics.TextureAtlas">
            <summary>
            A texture atlas, the texture2D can be loaded and unloaded from the GPU at any time
            We will keep the texture lists in memory all the time, though.
            </summary>
        </member>
        <member name="F:Murder.Core.Graphics.TextureAtlas._entries">
            <summary>Used publically only for the json serializer</summary>
        </member>
        <member name="M:Murder.Core.Graphics.TextureAtlas.CreateTextureFromAtlas(Murder.Core.Graphics.AtlasCoordinates,Microsoft.Xna.Framework.Graphics.SurfaceFormat,System.Int32)">
            <summary>
            This creates a new texture on the fly and should be *AVOIDED!*. Use `Get` instead.
            </summary>
            <param name="textureCoord">Coordinate of where the texture is located in the atlas.</param>
            <param name="format">Specifies the surface format. Some resources require Color or some other setting.</param>
            <param name="scale">Scale which will be applied to result.</param>
        </member>
        <member name="M:Murder.Core.Graphics.TextureAtlas.CreateTextureFromAtlas(System.String)">
            <summary>
            This creates a new texture on the fly and should be *AVOIDED!*. Use `Get` instead.
            </summary>
        </member>
        <member name="M:Murder.Core.Graphics.TextureAtlas.TryCreateTexture(System.String,Microsoft.Xna.Framework.Graphics.Texture2D@)">
            <summary>
            Create a texture on the fly. Be careful, as the texture needs to be manually *disposed*!
            </summary>
            <param name="id"></param>
            <param name="texture"></param>
            <returns></returns>
        </member>
        <member name="T:Murder.Core.MonoWorld">
            <summary>
            World implementation based in MonoGame.
            </summary>
            <summary>
            World implementation based in MonoGame.
            </summary>
        </member>
        <member name="F:Murder.Core.MonoWorld.RenderCounters">
            <summary>
            This has the duration of each render system (id) to its corresponding time (in ms).
            See <see cref="F:Bang.World.IdToSystem"/> on how to fetch the actual system.
            </summary>
        </member>
        <member name="F:Murder.Core.MonoWorld.GuiCounters">
            <summary>
            This has the duration of each gui render system (id) to its corresponding time (in ms).
            See <see cref="F:Bang.World.IdToSystem"/> on how to fetch the actual system.
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.IntRectangle.Touches(Murder.Core.Geometry.Rectangle)">
            <summary>
            Gets whether or not the other <see cref="T:Murder.Core.Geometry.Rectangle"/> intersects with this rectangle.
            </summary>
            <param name="other">The other rectangle for testing.</param>
            <returns><c>true</c> if other <see cref="T:Murder.Core.Geometry.Rectangle"/> intersects with this rectangle; <c>false</c> otherwise.</returns>
        </member>
        <member name="T:Murder.Core.Geometry.Line2">
            <summary>
            Class for a simple line with two points.
            This is based on a Otter2d class: https://github.com/kylepulver/Otter/blob/master/Otter/Utility/Line2.cs
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Line2.X1">
            <summary>
            The X position for the first point.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Line2.Y1">
            <summary>
            The Y position for the first point.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Line2.X2">
            <summary>
            The X position for the second point.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Line2.Y2">
            <summary>
            The Y position for the second point.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Line2.PointA">
            <summary>
            The first point of the line as a vector2.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Line2.PointB">
            <summary>
            The second point of a line as a vector2.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Line2.Bottom">
            <summary>
            The bottom most Y position of the line.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Line2.Top">
            <summary>
            The top most Y position of the line.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Line2.Left">
            <summary>
            The left most X position of the line.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Line2.Right">
            <summary>
            The right most X position of the line.
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.Line2.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Create a new Line2.
            </summary>
            <param name="x1">X of the first point</param>
            <param name="y1">Y of the first point</param>
            <param name="x2">X of the second point</param>
            <param name="y2">Y of the second point</param>
        </member>
        <member name="M:Murder.Core.Geometry.Line2.#ctor(Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2)">
            <summary>
            Create a new Line2.
            </summary>
            <param name="start">X,Y of the first point</param>
            <param name="end">X,Y of the second point</param>
        </member>
        <member name="M:Murder.Core.Geometry.Line2.Intersects(Murder.Core.Geometry.Line2)">
            <summary>
            Intersection test on another line. (http://ideone.com/PnPJgb)
            </summary>
            <param name="other">The line to test against</param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Line2.IntersectsRect(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Check intersection against a rectangle.
            </summary>
            <param name="x">X Position of the rectangle.</param>
            <param name="y">Y Position of the rectangle.</param>
            <param name="width">Width of the rectangle.</param>
            <param name="height">Height of the rectangle.</param>
            <returns>True if the line intersects any line on the rectangle, or if the line is inside the rectangle.</returns>
        </member>
        <member name="M:Murder.Core.Geometry.Line2.IntersectsCircle(Murder.Core.Geometry.Circle)">
            <summary>
            Check the intersection against a circle.
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.Line2.TryGetIntersectingPoint(Murder.Core.Geometry.Circle,Murder.Core.Geometry.Vector2@)">
            <summary>
            Returns if this line touches a circle and the first point of intersection.
            </summary>
            <param name="circle"></param>
            <param name="hitPoint"></param>
            <returns></returns>
        </member>
        <member name="T:Murder.Core.Geometry.Matrix">
            <summary>
            Implements a matrix within our engine. It can be converted to other matrix data types.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M11">
            <summary>
            A first row and first column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M12">
            <summary>
            A first row and second column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M13">
            <summary>
            A first row and third column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M14">
            <summary>
            A first row and fourth column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M21">
            <summary>
            A second row and first column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M22">
            <summary>
            A second row and second column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M23">
            <summary>
            A second row and third column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M24">
            <summary>
            A second row and fourth column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M31">
            <summary>
            A third row and first column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M32">
            <summary>
            A third row and second column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M33">
            <summary>
            A third row and third column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M34">
            <summary>
            A third row and fourth column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M41">
            <summary>
            A fourth row and first column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M42">
            <summary>
            A fourth row and second column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M43">
            <summary>
            A fourth row and third column value.
            </summary>
        </member>
        <member name="F:Murder.Core.Geometry.Matrix.M44">
            <summary>
            A fourth row and fourth column value.
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.Polygon.Intersects(Murder.Core.Geometry.Line2)">
            <summary>
            Checks if a line intersects the polygon
            </summary>
            <param name="line2"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Polygon.Intersects(Murder.Core.Geometry.Line2,Murder.Core.Geometry.Vector2@)">
            <summary>
            Checks if a line intersects with the polygon, and where.
            </summary>
            <param name="line2"></param>
            <param name="hitPoint"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Polygon.Intersects(Murder.Core.Geometry.Polygon,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2)">
            <summary>
            Check if a polygon is inside another, if they do, return the minimum translation vector to move the polygon out of the other.
            </summary>
            <param name="other"></param>
            <param name="positionA"></param>
            <param name="positionB"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Rectangle.FromCoordinates(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Constructor for a rectangle
            </summary>
            <param name="top"></param>
            <param name="bottom"></param>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Rectangle.TouchesWithMaxRotationCheck(Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2)">
            <summary>
            Whether an object within bounds intersects with this rectangle.
            This takes into account the "maximum" height and length given any rotation.
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.Rectangle.Touches(Murder.Core.Geometry.Rectangle)">
            <summary>
            Gets whether or not the other <see cref="T:Murder.Core.Geometry.Rectangle"/> intersects with this rectangle.
            </summary>
            <param name="other">The other rectangle for testing.</param>
            <returns><c>true</c> if other <see cref="T:Murder.Core.Geometry.Rectangle"/> intersects with this rectangle; <c>false</c> otherwise.</returns>
        </member>
        <member name="P:Murder.Core.Geometry.BoxShape.Rectangle">
            <summary>
            Simple shape getter
            </summary>
        </member>
        <member name="T:Murder.Core.Geometry.IShape">
            <summary>
            An IShape is a component which will be applied physics properties for collision.
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Vector2.Width">
            <summary>
            A quick shorthand for when using a vector as a "size"
            </summary>
        </member>
        <member name="P:Murder.Core.Geometry.Vector2.Height">
            <summary>
            A quick shorthand for when using a vector as a "size"
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.Vector2.LengthSquared">
            <summary>
            Cheaper than checking <see cref="M:Murder.Core.Geometry.Vector2.Length"/>, useful when comparing distances.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Vector2.CalculateAngle(Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2)">
            <summary>
             Calculates the internal angle of a triangle.
             </summary>
             <param name="a"></param>
             <param name="b"></param>
             <param name="c"></param>
             <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Vector2.FromAngle(System.Single)">
            <summary>
            Creates a vector from an angle in radians.
            </summary>
            <param name="angle">Angle in radians</param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Vector2.Rotate(System.Single)">
            <summary>
            Returns a new vector, rotated by the given angle. In radians.
            </summary>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Geometry.Vector2.ClampMagnitude(System.Single)">
            <summary>
            Clamps the magnetude of the vector
            </summary>
        </member>
        <member name="M:Murder.Core.Geometry.Vector2.Clamp(System.Single)">
            <summary>
            Clamps both X and Y to the given value, both positive an negatice
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Murder.Core.Map.HasLineOfSight(Murder.Core.Geometry.Point,Murder.Core.Geometry.Point,System.Boolean,System.Int32)">
            <summary>
            A fast Line of Sight check
            It is not exact by any means, just tries to draw A line of tiles between start and end.
            </summary>
            <param name="start">Starting tile</param>
            <param name="end">End tile</param>
            <param name="excludeEdges">Exclude starting and end tiles</param>
            <param name="blocking">Blocking tiles</param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Map.HasLineOfSight(Murder.Core.Geometry.Point,Murder.Core.Geometry.Point,System.Boolean,System.Func{System.Int32,System.Int32,System.Boolean})">
            <summary>
            A fast Line of Sight check
            It is not exact by any means, just tries to draw A line of tiles between start and end.
            </summary>
            <param name="start">Starting tile</param>
            <param name="end">End tile</param>
            <param name="excludeEdges">Exclude starting and end tiles</param>
            <param name="filter">The method to check for obsctacle. True means an obstacle was reached</param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Map.HasCollisionAt(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Check for collision using tiles coordinates.
            </summary>
        </member>
        <member name="M:Murder.Core.TileGrid.HasFlagAtGridPosition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Checks whether is solid at a position <paramref name="x"/> and <paramref name="y"/>.
            This will take a position from the grid (world) back to the local grid, using <see cref="P:Murder.Core.TileGrid.Origin"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.TileGrid.UnsetAll(System.Int32)">
            <summary>
            Unset all the tiles according to the bitness of <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.TileGrid.Resize(Murder.Core.Geometry.IntRectangle)">
            <summary>
            This supports resize the grid up to:
              _____      ______
             |     | -> |      |
             |_____x    |      |
                        |______x
            or
              _____      _____
             |  x  | -> |  x  |
             |_____|    |_____|
            
            Where x is the bullet point.
            </summary>
            <param name="rectangle"></param>
        </member>
        <member name="T:Murder.Core.Input.MurderInputButtons">
            <summary>
            Base class for input button constants, numbers from 100 to 120 are reserved for the engine.
            We recomend that if you need to create new constants for more gameplay buttons, start at 0.
            </summary>
        </member>
        <member name="T:Murder.Core.Input.MurderInputAxis">
            <summary>
            Base class for input axis constants, numbers from 100 to 120 are reserved for the engine.
            We recomend that if you need to create new constants for more gameplay axis, start at 0.
            </summary>
        </member>
        <member name="M:Murder.Core.Input.OptionsInfo.NextAvailableOption(System.Int32,System.Int32)">
            <param name="option">The currently selected option. If -1, it means that is being initialized.</param>
            <param name="direction">A sign number (1 or -1) with the direction.</param>
            <returns>The next option that is available.</returns>
        </member>
        <member name="P:Murder.Core.Input.PlayerInput.ScrollWheel">
            <summary>
            Scrollwheel delta
            </summary>
        </member>
        <member name="M:Murder.Core.Input.PlayerInput.Lock(System.Boolean)">
            <summary>
            Lock <see cref="F:Murder.Core.Input.PlayerInput._buttons"/> queries and do not propagate then to the game.
            </summary>
        </member>
        <member name="M:Murder.Core.Input.PlayerInput.Consume(System.Int32)">
            <summary>
            Consumes all buttons that have anything in common with this
            </summary>
            <param name="button"></param>
        </member>
        <member name="M:Murder.Core.Particles.Particle.CalculateColor(System.Single)">
            <summary>
            Calculate the color of a particle in a <paramref name="delta"/> with internal {0, 1}.
            </summary>
            <param name="delta">Delta from 0 to 1.</param>
        </member>
        <member name="M:Murder.Core.Particles.Particle.CalculateScale(System.Single)">
            <summary>
            Calculate the scale of a particle in a <paramref name="delta"/> with internal {0, 1}.
            </summary>
            <param name="delta">Delta from 0 to 1.</param>
        </member>
        <member name="F:Murder.Core.Particles.ParticleIntValueProperty._constant">
            <summary>
            Constant value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.Constant"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleIntValueProperty._rangeStart">
            <summary>
            Range value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.Range"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleIntValueProperty._rangeStartMin">
            <summary>
            Range value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.RangedStartAndRangedEnd"/>.
            </summary>
        </member>
        <member name="P:Murder.Core.Particles.ParticleRuntime.Delta">
            <summary>
            This is the lifetime of the particle over 0 to 1.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleRuntime._fromPosition">
            <summary>
            Used to track the position where this was fired.
            This is updated if <see cref="F:Murder.Core.Particles.Particle.FollowEntityPosition"/> is set.
            </summary>
        </member>
        <member name="M:Murder.Core.Particles.ParticleRuntime.Step(Murder.Core.Particles.Particle@,System.Single,System.Single)">
            <summary>
            Makes a step for a runtime particle.
            </summary>
            <param name="particle">Value on the particle based on the asset.</param>
            <param name="currentTime">Current time that the particle system exists.</param>
            <param name="dt">Delta time since the last Step call.</param>
        </member>
        <member name="F:Murder.Core.Particles.ParticleValueProperty._constant">
            <summary>
            Constant value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.Constant"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleValueProperty._rangeStart">
            <summary>
            Range value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.Range"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleValueProperty._rangeStartMin">
            <summary>
            Range value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.RangedStartAndRangedEnd"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Particles.ParticleValueProperty.GetValueAt(System.Single)">
            <summary>
            Get the value of this property over a delta lifetime.
            </summary>
            <param name="delta">Delta ranges from 0 to 1.</param>
        </member>
        <member name="F:Murder.Core.Particles.ParticleVectorValueProperty._constant">
            <summary>
            Constant value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.Constant"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleVectorValueProperty._rangeStart">
            <summary>
            Range value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.Range"/>.
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.ParticleVectorValueProperty._rangeStartMin">
            <summary>
            Range value set when <see cref="F:Murder.Core.Particles.ParticleValuePropertyKind.RangedStartAndRangedEnd"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.Particles.ParticleVectorValueProperty.GetValueAt(System.Single)">
            <summary>
            Get the value of this property over a delta lifetime.
            </summary>
            <param name="delta">Delta ranges from 0 to 1.</param>
        </member>
        <member name="F:Murder.Core.Particles.ParticleSystemTracker._intervalPerParticleSpawn">
            <summary>
            Interval of time before a new particle is spawned.
            </summary>
        </member>
        <member name="P:Murder.Core.Particles.ParticleSystemTracker.LastEmitterPosition">
            <summary>
            The last position of the emitter.
            </summary>
        </member>
        <member name="M:Murder.Core.Particles.ParticleSystemTracker.Step(System.Single,System.Boolean,Murder.Core.Geometry.Vector2)">
            <summary>
            Makes a "step" throughout the particle system.
            </summary>
            <param name="dt">Delta time.</param>
            <param name="allowSpawn">Whether spawning new entities is allowed, e.g. the entity is not deactivated.</param>
            <param name="emitterPosition">Emitter position in game where the particles are fired from.</param>
            <returns>Returns whether the emitter is still running.</returns>
        </member>
        <member name="F:Murder.Core.Particles.WorldParticleSystemTracker._particleSystems">
            <summary>
            List of all the particle systems that currently exist in the world.
            Maps:
            [ Entity Id -> Index of tracker in the pool ]
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.WorldParticleSystemTracker._indexToEntityId">
            <summary>
            List of all the particle systems that currently exist in the world.
            Maps:
            [ Index of tracker in the pool -> EntityId ]
            </summary>
        </member>
        <member name="F:Murder.Core.Particles.WorldParticleSystemTracker._activeParticleSystems">
            <summary>
            List of all the <see cref="F:Murder.Core.Particles.WorldParticleSystemTracker._particleSystems"/> that are currently active.
            </summary>
        </member>
        <member name="M:Murder.Core.Particles.WorldParticleSystemTracker.FetchActiveParticleTrackers">
            <summary>
            Fetch all the active particle trackers.
            </summary>
        </member>
        <member name="M:Murder.Core.Physics.CollisionLayersBase.#ctor">
            <summary>
            This class should never be instanced
            </summary>
        </member>
        <member name="M:Murder.Core.Physics.QTNode`1.Clear">
            <summary>
            Recursivelly clears all entities of the node, but keeps the strtucture
            </summary>
        </member>
        <member name="M:Murder.Core.Physics.QTNode`1.Reset">
            <summary>
            Completelly resets the node removing anything inside
            </summary>
        </member>
        <member name="M:Murder.Core.Physics.QTNode`1.GetIndex(Murder.Core.Geometry.Rectangle)">
            <summary>
            Determine which node the object belongs to. -1 means
            object cannot completely fit within a child node and is part
            of the parent node
            </summary>
            <param name="boundingBox"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Core.Physics.QTNode`1.Insert(`0,Murder.Core.Geometry.Rectangle)">
            <summary>
            Insert the object into the quadtree. If the node
            exceeds the capacity, it will split and add all
            objects to their corresponding nodes.
            </summary>
        </member>
        <member name="M:Murder.Core.Physics.QTNode`1.Retrieve(Murder.Core.Geometry.Rectangle,System.Collections.Generic.List{System.ValueTuple{`0,Murder.Core.Geometry.Rectangle}}@)">
            <summary>
            Return all objects that could collide with the given object at <paramref name="returnEntities"/>.
            </summary>
        </member>
        <member name="P:Murder.Core.Scene.RenderContext">
            <summary>
            Context renderer unique to this scene.
            </summary>
        </member>
        <member name="F:Murder.Core.Scene._onRefreshWindow">
            <summary>
            Used to track events when the window (UI) refreshes.
            </summary>
        </member>
        <member name="M:Murder.Core.Scene.Reload">
            <summary>
            Reload the active scene.
            </summary>
        </member>
        <member name="M:Murder.Core.Scene.Suspend">
            <summary>
            Rests the current scene temporarily.
            </summary>
        </member>
        <member name="M:Murder.Core.Scene.DrawGui">
            <summary>
            Scenes that would like to implement a Gui should use this method.
            </summary>
        </member>
        <member name="M:Murder.Core.Scene.AddOnWindowRefresh(System.Action)">
            <summary>
            This will trigger UI refresh operations.
            </summary>
        </member>
        <member name="M:Murder.Core.Scene.ResetWindowRefreshEvents">
            <summary>
            This will reset all watchers of trackers.
            </summary>
        </member>
        <member name="M:Murder.Core.SceneLoader.SwitchScene``1">
            <summary>
            Switch to a scene of type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.SceneLoader.SwitchScene(Murder.Core.Scene)">
            <summary>
            Switch to <paramref name="scene"/>.
            </summary>
        </member>
        <member name="M:Murder.Core.SceneLoader.LoadContentAsync">
            <summary>
            Load the content of the current active scene.
            </summary>
        </member>
        <member name="M:Murder.Core.Sounds.ISoundPlayer.PlayEvent(Murder.Core.Sounds.SoundEventId,System.Boolean,System.Boolean)">
            <summary>
            Play a sound/event with the id of <paramref name="id"/>.
            If <paramref name="isLoop"/> is set, the sound will be persisted.
            </summary>
        </member>
        <member name="M:Murder.Core.Sounds.ISoundPlayer.PlayStreaming(Murder.Core.Sounds.SoundEventId,System.Boolean)">
            <summary>
            Start a streaming sound/event in the background.
            This is called for music or ambience sounds.
            </summary>
        </member>
        <member name="M:Murder.Core.Sounds.ISoundPlayer.Stop(System.Boolean)">
            <summary>
            Stop all active streaming events.
            If <paramref name="fadeOut"/> is set, this will stop with a fadeout.
            </summary>
        </member>
        <member name="M:Murder.Core.Sounds.ISoundPlayer.SetVolume(System.Nullable{Murder.Core.Sounds.SoundEventId},System.Single)">
            <summary>
            Change volume.
            </summary>
        </member>
        <member name="M:Murder.Core.Sounds.SoundPlayer.SetVolume(System.Nullable{Murder.Core.Sounds.SoundEventId},System.Single)">
            <summary>
            Change volume.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager._database">
            <summary>
            Maps:
            [Game asset type] -> [Guid] 
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager._allAssets">
            <summary>
            Maps:
            [Guid] -> [Asset]
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.LargeFont">
            <summary>
            A larger, 12 pixel tall font TODO: Is this font broken??
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.MediumFont">
            <summary>
            A small, 7 pixel tall font
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.PixelFont">
            <summary>
            A small, 7 pixel tall font
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.ShaderSimple">
            <summary>
            The cheapest and simplest shader.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.ShaderSprite">
            <summary>
            Actually a fancy shader, has some sprite effect tools for us, like different color blending modes.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.BloomShader">
            <summary>
            A shader that can blur and find brightness areas in images
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.PosterizerShader">
            <summary>
            A shader that can blur and find brightness areas in images
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager.CustomGameShader">
            <summary>
            Custom optional game shader, provided by <see cref="F:Murder.Data.GameDataManager._game"/>.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.#ctor(Murder.IMurderGame)">
            <summary>
            Creates a new game data manager.
            </summary>
            <param name="game">This is set when overriding Murder utilities.</param>
        </member>
        <member name="M:Murder.Data.GameDataManager.LoadShaders(System.Boolean)">
            <summary>
            Override this to load all shaders present in the game.
            </summary>
            <param name="breakOnFail">Whether we should break if this fails.</param>
        </member>
        <member name="M:Murder.Data.GameDataManager.LoadShader(System.String,Microsoft.Xna.Framework.Graphics.Effect@,System.Boolean)">
            <summary>
            Load and return shader of name <paramref name="name"/>.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.GetAsepriteFrame(System.Guid)">
            <summary>
            Quick and dirty way to get a aseprite frame, animated when you don't want to deal with the animation system.
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Data.GameDataManager.TryGetAsset(System.Guid)">
            <summary>
            Get a generic asset with a <paramref name="id"/>.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.FindAllNamesForAsset(System.Type)">
            <summary>
            Find all the assets names for an asset type <paramref name="t"/>.
            </summary>
            <param name="t">The type that inherist from <see cref="T:Murder.Assets.GameAsset"/>.</param>
        </member>
        <member name="M:Murder.Data.GameDataManager.FilterAllAssetsWithImplementation(System.Type[])">
            <summary>
            Filter all the assets and any types that implement those types.
            Cautious: this may be slow or just imply extra allocations.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.FilterOutAssets(System.Type[])">
            <summary>
            Return all the assets except the ones in <paramref name="types"/>.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.CreateSaveData(System.String)">
            <summary>
            Creates an implementation of SaveData for the game.
            </summary>
        </member>
        <member name="P:Murder.Data.GameDataManager.GameDirectory">
            <summary>
            Directory used for saving custom data.
            </summary>
        </member>
        <member name="P:Murder.Data.GameDataManager.SaveBasePath">
            <summary>
            Save directory path used when serializing user data.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager._allSavedData">
            <summary>
            This is the collection of save data.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager._currentSaveAssets">
            <summary>
            Stores all the save assets tied to the current <see cref="P:Murder.Data.GameDataManager.ActiveSaveData"/>.
            </summary>
        </member>
        <member name="P:Murder.Data.GameDataManager.ActiveSaveData">
            <summary>
            Active saved run in the game.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.TryGetActiveSaveData">
            <summary>
            Active saved run in the game.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.ResetActiveSave">
            <summary>
            This resets the active save data.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.GetAllSaves">
            <summary>
            List all the available saves within the game.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.CreateSave(System.String)">
            <summary>
            Create a new save data based on a name.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.GetDynamicAsset``1">
            <summary>
            Retrieve a dynamic asset within the current save data.
            If no dynamic asset is found, it creates a new one to the save data.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.TryGetAssetForCurrentSave(System.Guid)">
            <summary>
            Retrieve a dynamic asset within the current save data based on a guid.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.CreateSaveData(Murder.Assets.SaveData)">
            <summary>
            Create a new save data for the game.
            </summary>
            <param name="asset">
            Save data asset. This might have any custom user settings.
            </param>
            <returns>
            Whether the save succeeded.
            </returns>
        </member>
        <member name="M:Murder.Data.GameDataManager.QuickSave">
            <summary>
            Quickly serialize our save assets.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.UnloadAllSaves">
            <summary>
            Used to clear all saves files currently active.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager._cachedSounds">
            <summary>
            TODO: Limit cache size.
            </summary>
        </member>
        <member name="F:Murder.Data.GameDataManager._soundDatabase">
            <summary>
            Sound database.
            Maps:
              [Sound name -> Sound path]
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.LoadSounds">
            <summary>
            This will load all the sounds to the game.
            </summary>
        </member>
        <member name="M:Murder.Data.GameDataManager.PreprocessSoundFiles">
            <summary>
            Implemented by custom implementations of data manager that want to do some preprocessing on the sounds.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.EntityBuilder.Create(Bang.World,System.Guid,System.Collections.Immutable.ImmutableArray{Bang.Components.IComponent}@,System.Collections.Immutable.ImmutableArray{Murder.Prefabs.EntityInstance}@,System.Collections.Immutable.ImmutableDictionary{System.Guid,Murder.Prefabs.EntityModifier}@,System.Nullable{System.Int32})">
            <summary>
            Create entity at a particular position. This will override the default position of the parent.
            Called from <see cref="M:Murder.Prefabs.EntityInstance.Create(Bang.World,Murder.Prefabs.IEntity)"/>.
            </summary>
            <param name="asset">The guid of the prefab to be created.</param>
            <param name="world">World in which this entity will be added.</param>
            <param name="components">Custom components for the instance. This overrides any existing components
            in the entity asset.</param>
            <param name="children">Children for the instance.</param>
            <param name="modifiers">List of custom customizations to the prefab components.</param>
            <param name="id">Optional identifier of the entity within the world. If this conflicts with another existing id, it will be ignored.</param>
            <returns>
            Parent entity id.
            TODO: Do we need to return the id of all the children as well?
            </returns>
        </member>
        <member name="M:Murder.Prefabs.EntityBuilder.CreateChildren(Bang.World,System.Collections.Immutable.ImmutableArray{Murder.Prefabs.EntityInstance}@,System.Collections.Immutable.ImmutableDictionary{System.Guid,Murder.Prefabs.EntityModifier}@)">
            <summary>
            Create all the children to <paramref name="world"/>.
            </summary>
            <returns>
            List of all children created within the world.
            </returns>
        </member>
        <member name="T:Murder.Prefabs.EntityInstance">
            <summary>
            Represents an entity as an instance placed on the map.
            This map may be relative to the world or another entity.
            </summary>
        </member>
        <member name="F:Murder.Prefabs.EntityInstance.Id">
            <summary>
            Entity id, if any. This will be persisted across save files.
            This only exists for instances in the world.
            </summary>
        </member>
        <member name="P:Murder.Prefabs.EntityInstance.PrefabRefName">
            <summary>
            By default, this is not based on any prefab.
            Return null.
            </summary>
        </member>
        <member name="F:Murder.Prefabs.EntityInstance._components">
            <summary>
            List of custom components that difer from the parent entity.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.HasNonIntrinsicComponent">
            <summary>
            Checks whether this entity has any non-intrinsic components, whether it's
            a distinct entity within the world.
            See <see cref="T:Murder.Attributes.IntrinsicAttribute"/>.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.Create(Bang.World)">
            <summary>
            Create the instance entity in the world.
            </summary>
            <param name="world">The world this instance will be tied to.</param>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.Create(Bang.World,Murder.Prefabs.IEntity)">
            <summary>
            Create the instance entity in the world with a specified parent.
            </summary>
            <param name="world">The world this instance will be tied to.</param>
            <param name="parent">The parent, which may have custom modifiers.</param>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.Create(Bang.World,System.Collections.Immutable.ImmutableDictionary{System.Guid,Murder.Prefabs.EntityModifier}@)">
            <summary>
            Create the instance entity in the world with a list of modifiers.
            </summary>
            <param name="world">The world this instance will be tied to.</param>
            <param name="modifiers">Components which might override any of the instances.</param>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.CreateInternal(Bang.World,System.Guid,System.Collections.Immutable.ImmutableDictionary{System.Guid,Murder.Prefabs.EntityModifier}@)">
            <summary>
            Create the instance entity with a given asset in the world with a list of modifiers.
            This filters the modifiers according the children and components.
            </summary>
            <param name="world">The world this instance will be tied to.</param>
            <param name="asset">Prefab identifier.</param>
            <param name="modifiers">Components which might override any of the instances.</param>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.IsComponentInAsset(Bang.Components.IComponent)">
            <summary>
            Returns whether a component is present in the entity asset.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.HasComponent(System.Type)">
            <summary>
            Returns whether an instance of <paramref name="type"/> exists in the list of components.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.SetName(System.String)">
            <summary>
            Set the name of the entity instance.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.EntityInstance.GetChildComponents(System.Guid)">
            <summary>
            Try to get the components for a child.
            TODO: Do not expose the instance children directly...? Is this only necessary for prefabs?
            Are we limiting the amount of children recursive to two?
            </summary>
            <param name="guid"></param>
        </member>
        <member name="M:Murder.Prefabs.EntityModifier.ApplyModifiersFrom(Murder.Prefabs.EntityModifier)">
            <summary>
            Merge modifier with <paramref name="other"/>.
            This will prioritize items present in <paramref name="other"/>.
            </summary>
        </member>
        <member name="P:Murder.Prefabs.IEntity.PrefabRefName">
            <summary>
            If this has a prefab reference, this will return its name.
            Otherwise, return null.
            </summary>
        </member>
        <member name="P:Murder.Prefabs.IEntity.Components">
            <summary>
            Returns all the components of the entity asset, followed by all the components of the instance.
            </summary>
        </member>
        <member name="P:Murder.Prefabs.IEntity.Children">
            <summary>
            Returns all the identifiers for this entity children.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.IEntity.FetchChildren">
            <summary>
            **INTERNAL ONLY**
            Fetches the actual entities for all children.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.IEntity.Create(Bang.World)">
            <summary>
            Create the entity in the world!
            </summary>
            <returns>The entity id in this world.</returns>
        </member>
        <member name="F:Murder.Prefabs.PrefabEntityInstance.PrefabRef">
            <summary>
            This is the guid of the <see cref="T:Murder.Assets.PrefabAsset"/> that this refers to.
            </summary>
        </member>
        <member name="F:Murder.Prefabs.PrefabEntityInstance._removeComponent">
            <summary>
            List of custom components that have been removed from the parent entity, if any.
            </summary>
        </member>
        <member name="P:Murder.Prefabs.PrefabEntityInstance.Components">
            <summary>
            Returns all the components of the entity asset, followed by all the components of the instance.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.FetchChildren">
            <summary>
            Returns all the children of the entity asset, followed by all the children of the instance.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.Create(Bang.World)">
            <summary>
            Create the instance entity in the world.
            </summary>
            <param name="world">The world this instance will be tied to.</param>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.Create(Bang.World,System.Collections.Immutable.ImmutableDictionary{System.Guid,Murder.Prefabs.EntityModifier}@)">
            <summary>
            Create the instance entity in the world with a list of modifiers.
            </summary>
            <param name="world">The world this instance will be tied to.</param>
            <param name="modifiers">Components which might override any of the instances.</param>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.IsComponentInAsset(Bang.Components.IComponent)">
            <summary>
            Returns whether a component is present in the entity asset.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.HasComponent(System.Type)">
            <summary>
            Returns whether an instance of <paramref name="type"/> exists in the list of components.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.CanModifyChildAt(System.Guid)">
            <summary>
            This checks whether a child can be modified.
            This means that it does not belong to any prefab reference.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.GetChildComponents(System.Guid)">
            <summary>
            Fetch the components for a given child.
            This will filter any modifiers made to the children components.
            </summary>
        </member>
        <member name="M:Murder.Prefabs.PrefabEntityInstance.FetchChildChildren(Murder.Prefabs.IEntity)">
            <summary>
            Get all the children of a child.
            This will take into account any modifiers of the parent.
            </summary>
        </member>
        <member name="T:Murder.Prefabs.PrefabReference">
            <summary>
            Represents an entity placed on the map.
            </summary>
        </member>
        <member name="F:Murder.Prefabs.PrefabReference.Guid">
            <summary>
            Reference to a <see cref="T:Murder.Assets.PrefabAsset"/>.
            </summary>
        </member>
        <member name="T:Murder.Save.BlackboardTracker">
            <summary>
            Track variables that contain the state of the world.
            </summary>
        </member>
        <member name="F:Murder.Save.BlackboardTracker._variablesWithoutBlackboard">
            <summary>
            Tracks properties that does not belong in any blackboard and only take place
            in the story.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.FetchCharacterFor(System.Guid)">
            <summary>
            Fetch a cached character out of <see cref="F:Murder.Save.BlackboardTracker._characterCache"/>
            </summary>
            <param name="guid">The asset guid for the character script.</param>
            <returns>Null if unable to find the asset for <paramref name="guid"/>.</returns>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.FindBlackboard(System.String,System.Nullable{System.Guid})">
            <summary>
            Try to find a blackboard with name <paramref name="name"/>. 
            If this is specific to a character script, look under <paramref name="guid"/>.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.Track(System.Guid,System.Int32,System.Int32)">
            <summary>
            Track that a particular dialog option has been played.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.HasPlayed(System.Guid,System.Int32,System.Int32)">
            <summary>
            Returns whether a particular dialog option has been played.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.PlayCount(System.Guid,System.Int32,System.Int32)">
            <summary>
            Returns whether how many times a dialog has been executed.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.GetValueAsString(System.String)">
            <summary>
            Get a blackboard value as a string. This returns the first blackboard that has the field.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.HasVariable(System.String,System.String)">
            <summary>
            Return whether a <paramref name="fieldName"/> exists on <paramref name="blackboardName"/>.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.GetValue``1(System.String)">
            <summary>
            Fetch a variable value that is not available in any blackboard.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.SetValue``1(System.String,``0)">
            <summary>
            Set a variable value that is not available in any blackboard.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.OnModified">
            <summary>
            Notify that the blackboard has been changed (externally or internally).
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.Watch(System.Action)">
            <summary>
            This will watch any chages to any of the blackboard properties.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.ResetWatchers">
            <summary>
            This will reset all watchers of trackers.
            </summary>
        </member>
        <member name="M:Murder.Save.BlackboardTracker.Matches(Murder.Core.Dialogs.Criterion,System.Nullable{System.Guid},Bang.World,System.Nullable{System.Int32},System.Int32@)">
            <summary>
            Returns whether a <paramref name="criterion"/> matches the current state of the blackboard and
            its score.
            </summary>
            <param name="criterion">The criterion to be matched.</param>
            <param name="character">This is used when checking for a particular character blackboard.</param>
            <param name="world">World.</param>
            <param name="entityId">Entity which will be used to check for components requirements.</param>
            <param name="weight">The weight of this match. Zero if there is a no match.</param>
        </member>
        <member name="T:Murder.Save.GamePreferences">
            <summary>
            Tracks preferences of the current session. This is unique per run.
            Used to track the game settings that are not tied to any game run (for example, volume).
            </summary>
        </member>
        <member name="M:Murder.Save.GamePreferences.ToggleSoundVolumeAndSave">
            <summary>
            This toggles the volume to the opposite of the current setting.
            Immediately serialize (and save) afterwards.
            </summary>
        </member>
        <member name="M:Murder.Save.GamePreferences.ToggleMusicVolumeAndSave">
            <summary>
            This toggles the volume to the opposite of the current setting.
            Immediately serialize (and save) afterwards.
            </summary>
        </member>
        <member name="T:Murder.Save.SavedWorldBuilder">
            <summary>
            Asset for a map that has been generated within a world.
            </summary>
        </member>
        <member name="F:Murder.Save.SavedWorldBuilder._allChildrenEntities">
            <summary>
            Keeps track of all the children which have been added into their parents.
            </summary>
        </member>
        <member name="F:Murder.Save.SavedWorldBuilder._skipEntities">
            <summary>
            Speed things up by keeping track of entities which will be skipped.
            </summary>
        </member>
        <member name="M:Murder.Save.SavedWorldBuilder.TryConvertToInstance(Bang.Entities.Entity)">
            <summary>
            Convert this entity to a an instance which has not been placed in the world.
            </summary>
            <param name="e"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Save.SavedWorldBuilder.FilterComponents(Murder.Prefabs.EntityInstance@,System.Collections.Immutable.ImmutableArray{Bang.Components.IComponent})">
            <summary>
            Filter the components for a given instance.
            </summary>
            <returns>If false, this entity should not be serialized.</returns>
        </member>
        <member name="T:Murder.Diagnostics.ICommands">
            <summary>
            Implemented by static classes that would like to export command functionality.
            </summary>
        </member>
        <member name="F:Murder.Diagnostics.GameLogger._lastInputs">
            <summary>
            These are for supporting ^ functionality in console. Fancyy....
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.#ctor">
            <summary>
            This is a singleton.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.DrawConsole(System.Func{System.String,System.String})">
            <summary>
            Draws the console of the game.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.TopBar(System.Boolean@)">
            <summary>
            Shows the top bar of the console. Called when a console is displayed.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.LogText(System.Boolean)">
            <summary>
            Log text in the console display. Called when a console is displayed.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.Input(System.Func{System.String,System.String})">
            <summary>
            Receive input from the user. Called when a console is displayed.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.Fail(System.String)">
            <summary>
            This will fail a given message and paste it in the log.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.Verify(System.Boolean)">
            <summary>
            This will verify a condition. If false, this will paste in the log.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.Verify(System.Boolean,System.String)">
            <summary>
            This will verify a condition. If false, this will paste <paramref name="message"/> in the log.
            </summary>
        </member>
        <member name="M:Murder.Diagnostics.GameLogger.CaptureCrash(System.Exception,System.String)">
            <summary>
            Used to filter exceptions once a crash is yet to happen.
            </summary>
        </member>
        <member name="T:Murder.Diagnostics.SmoothFpsCounter">
            <summary>
            This will smooth the average FPS of the game.
            </summary>
        </member>
        <member name="P:Murder.Diagnostics.SmoothFpsCounter.Value">
            <summary>
            Latest FPS value.
            </summary>
        </member>
        <member name="P:Murder.Game.Instance">
            <summary>
            Singleton instance of the game. Be cautious when referencing this...
            </summary>
        </member>
        <member name="F:Murder.Game._sceneLoader">
            <summary>
            Initialized in <see cref="M:Murder.Game.LoadContent"/>.
            </summary>
        </member>
        <member name="P:Murder.Game.ElapsedTime">
            <summary>
            Elapsed time in seconds since the game started
            </summary>
        </member>
        <member name="F:Murder.Game._freezeFrameCount">
            <summary>
            If set, this is the amount of frames we will skip while rendering.
            </summary>
        </member>
        <member name="F:Murder.Game._isSkippingDeltaTimeOnUpdate">
            <summary>
            Whether the player is currently skipping frames (due to cutscene) and ignore
            the time while calling update methods.
            </summary>
        </member>
        <member name="P:Murder.Game.IsSkippingDeltaTimeOnUpdate">
            <summary>
            Whether the player is currently skipping frames (due to cutscene) and ignore
            the time while calling update methods.
            </summary>
        </member>
        <member name="F:Murder.Game._game">
            <summary>
            This is the underlying implementation of the game. This listens to the murder game events.
            </summary>
        </member>
        <member name="F:Murder.Game._logger">
            <summary>
            Single logger of the game.
            </summary>
        </member>
        <member name="M:Murder.Game.#ctor(Murder.IMurderGame,Murder.Data.GameDataManager)">
            <summary>
            Creates a new game, there should only be one game instance ever.
            If <paramref name="dataManager"/> is not initialized, it will create the starting scene from <see cref="T:Murder.Assets.GameProfile"/>.
            </summary>
        </member>
        <member name="M:Murder.Game.ApplyGameSettings">
            <summary>
            This will apply the game settings according to <see cref="T:Murder.Assets.GameProfile"/>, loaded with <see cref="F:Murder.Game._gameData"/>. />.
            </summary>
        </member>
        <member name="M:Murder.Game.Pause">
            <summary>
            This will pause the game.
            </summary>
        </member>
        <member name="M:Murder.Game.FreezeFrames(System.Int32)">
            <summary>
            This will pause the game for <paramref name="amount"/> of frames.
            </summary>
        </member>
        <member name="M:Murder.Game.SkipDeltaTimeOnUpdate">
            <summary>
            This will skip update times and immediately run the update calls from the game 
            until <see cref="M:Murder.Game.ResumeDeltaTimeOnUpdate"/> is called.
            </summary>
        </member>
        <member name="M:Murder.Game.ResumeDeltaTimeOnUpdate">
            <summary>
            Resume game to normal game time.
            </summary>
        </member>
        <member name="M:Murder.Game.SlowDown(System.Single)">
            <summary>
            This will slow down the game time.
            TODO: What if we have multiple slow downs in the same run?
            </summary>
        </member>
        <member name="M:Murder.Game.Resume">
            <summary>
            This will resume the game.
            </summary>
        </member>
        <member name="M:Murder.Game.ExitGame">
            <summary>
            Exit the game. This is used to wrap any custom behavior depending on the game implementation.
            </summary>
        </member>
        <member name="T:Murder.IMurderGame">
            <summary>
            This is the main loop of a murder game. This has the callbacks to relevant events in the game.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.Initialize">
            <summary>
            Called once, when the executable for the game starts and initializes.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.LoadContentAsync">
            <summary>
            This loads all the content within the game. Called after <see cref="M:Murder.IMurderGame.Initialize"/>.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.OnUpdate">
            <summary>
            Called after each update.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.OnDraw">
            <summary>
            Called after each draw.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.OnSceneTransition">
            <summary>
            Called before a scene transition.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.OnExit">
            <summary>
            Called once the game exits.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.CreateSaveData(System.String)">
            <summary>
            Creates save data for the game.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.CreateSoundPlayer">
            <summary>
            Creates the client custom sound player.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.CreateGameProfile">
            <summary>
            Creates a custom game profile for the game.
            </summary>
        </member>
        <member name="M:Murder.IMurderGame.CreateGamePreferences">
            <summary>
            Creates a custom game preferences for the game.
            </summary>
        </member>
        <member name="P:Murder.IMurderGame.Name">
            <summary>
            This is the name of the game, used when creating assets and loading save data.
            </summary>
        </member>
        <member name="T:Murder.Interactions.AddComponentOnInteraction">
            <summary>
            This will trigger an effect by placing <see cref="F:Murder.Interactions.AddComponentOnInteraction.Component"/> in the world.
            </summary>
        </member>
        <member name="T:Murder.Interactions.AddEntityOnInteraction">
            <summary>
            This will trigger an effect by placing <see cref="F:Murder.Interactions.AddEntityOnInteraction._prefab"/> in the world.
            </summary>
        </member>
        <member name="F:Murder.Interactions.BlackboardAction._requirements">
            <summary>
            List of requirements which will trigger the interaction.
            </summary>
        </member>
        <member name="F:Murder.Interactions.TalkToInteraction.Situation">
            <summary>
            This is the starter situation for the interaction.
            </summary>
        </member>
        <member name="T:Murder.Interactions.InteractionCollection">
            <summary>
            This triggers a list of different interactions within this entity.
            </summary>
        </member>
        <member name="F:Murder.Interactions.SendToOtherInteraction._targets">
            <summary>
            Guid of the target entity.
            </summary>
        </member>
        <member name="T:Murder.IShaderProvider">
            <summary>
            A game that leverages murder and use custom shaders should implement this in their <see cref="T:Murder.IMurderGame"/>.
            </summary>
        </member>
        <member name="P:Murder.IShaderProvider.Shaders">
            <summary>
            Names of custom shaders that will be provided.
            This is expected to be placed in ./<game_directory/>/../resources
            </summary>
        </member>
        <member name="T:Murder.Messages.FatalDamageMessage">
            <summary>
            A message signaling that this entity should be killed
            </summary>
        </member>
        <member name="T:Murder.Messages.InteractMessage">
            <summary>
            Generic struct for interacting with an entity.
            </summary>
        </member>
        <member name="T:Murder.Messages.OnInteractExitMessage">
            <summary>
            Generic struct for notifying that an interaction exit has occurred.
            </summary>
        </member>
        <member name="M:Murder.Messages.CollidedWithMessage.#ctor(System.Int32,Murder.Core.Geometry.Vector2)">
            <summary>
            Signals a collision with another entity
            </summary>
            <param name="entityId">The scene ID of the other entity</param>
        </member>
        <member name="M:Murder.Messages.Physics.OnActorEnteredOrExitedMessage.#ctor(System.Int32,Murder.Utilities.CollisionDirection)">
            <summary>
            Message sent to the TRIGGER when touching an actor touches it.
            </summary>
        </member>
        <member name="M:Murder.Messages.Physics.OnTriggerEnteredMessage.#ctor(System.Int32,Murder.Utilities.CollisionDirection)">
            <summary>
            Message sent to the ACTOR when touching a trigger area.
            </summary>
        </member>
        <member name="M:Murder.Services.EffectsServices.FadeIn(Bang.World,System.Single,Murder.Core.Graphics.Color,System.Boolean)">
            <summary>
            Add an entity which will apply a "fade-in" effect. Darkening the screen to black.
            </summary>
        </member>
        <member name="M:Murder.Services.EffectsServices.FadeOut(Bang.World,System.Single,Murder.Core.Graphics.Color,System.Single,System.Boolean)">
            <summary>
            Add an entity which will apply a "fade-out" effect. Clearing the screeen.
            </summary>
        </member>
        <member name="M:Murder.Services.EntityServices.GetAllTreeOfEntities(Bang.World,Bang.Entities.Entity)">
            <summary>
            Recursivelly get all children of this entity, including itself.
            </summary>
            <param name="world">World that this entity belongs.</param>
            <param name="entity">Entity target.</param>
        </member>
        <member name="M:Murder.Services.EntityServices.TryFindTarget(Bang.Entities.Entity,Bang.World)">
            <summary>
            Try to find the target of a <see cref="T:Murder.Components.GuidToIdTargetComponent"/>.
            </summary>
        </member>
        <member name="M:Murder.Services.EntityServices.TryFindTarget(Bang.Entities.Entity,Bang.World,System.String)">
            <summary>
            Try to find the target of a <see cref="T:Murder.Components.GuidToIdTargetCollectionComponent"/>.
            </summary>
        </member>
        <member name="M:Murder.Services.GeometryServices.CreateCircle(System.Double,System.Int32)">
            <summary>
            Creates a list of vectors that represents a circle
            </summary>
            <param name="radius">The radius of the circle</param>
            <param name="sides">The number of sides to generate</param>
            <returns>A list of vectors that, if connected, will create a circle</returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.CheckOverlap(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Check if two ranges overlap at any point.
            </summary>
        </member>
        <member name="M:Murder.Services.GeometryServices.CheckOverlap(System.ValueTuple{System.Single,System.Single},System.ValueTuple{System.Single,System.Single})">
            <summary>
            Check if two ranges overlap at any point.
            </summary>
        </member>
        <member name="M:Murder.Services.GeometryServices.SignedPolygonArea(Murder.Core.Geometry.Vector2[])">
            <summary>
            Calculates the signed area of a polygon.
            The signed area is positive if the vertices are in clockwise order,
            and negative if the vertices are in counterclockwise order.
            </summary>
            <param name="vertices"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.IsConvex(Murder.Core.Geometry.Vector2[],System.Boolean)">
            <summary>
            Determines if a polygon is convex or not.
            </summary>
            <param name="vertices"></param>
            <param name="isClockwise"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.InRect(System.Single,System.Single,Murder.Core.Geometry.Rectangle)">
            <summary>
            Check for a point in a rectangle.
            </summary>
            <param name="x">The X position of the point to check.</param>
            <param name="y">The Y position of the point to check.</param>
            <param name="rect">The rectangle.</param>
            <returns>True if the point is in the rectangle.</returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.InRect(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Check for a point in a rectangle.
            </summary>
            <param name="x">The X position of the point to check.</param>
            <param name="y">The Y position of the point to check.</param>
            <param name="rx">The left of the rectangle.</param>
            <param name="ry">The top of the rectangle.</param>
            <param name="rw">The width of the rectangle.</param>
            <param name="rh">The height of the rectangle.</param>
            <returns>True if the point is in the rectangle.</returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.InRect(Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Rectangle)">
            <summary>
            Check for a point in a rectangle.
            </summary>
            <param name="xy">The X and Y position of the point to check.</param>
            <param name="rect">The rectangle.</param>
            <returns>True if the point is in the rectangle.</returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.Distance(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Distance check.
            </summary>
            <param name="x1">The first X position.</param>
            <param name="y1">The first Y position.</param>
            <param name="x2">The second X position.</param>
            <param name="y2">The second Y position.</param>
            <returns>The distance between the two points.</returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.DistanceRectPoint(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Find the distance between a point and a rectangle.
            </summary>
            <param name="px">The X position of the point.</param>
            <param name="py">The Y position of the point.</param>
            <param name="rx">The X position of the rectangle.</param>
            <param name="ry">The Y position of the rectangle.</param>
            <param name="rw">The width of the rectangle.</param>
            <param name="rh">The height of the rectangle.</param>
            <returns>The distance.  Returns 0 if the point is within the rectangle.</returns>
        </member>
        <member name="M:Murder.Services.GeometryServices.DistanceLinePoint(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Distance between a line and a point.
            </summary>
            <param name="x">The X position of the point.</param>
            <param name="y">The Y position of the point.</param>
            <param name="x1">The first X position of the line.</param>
            <param name="y1">The first Y position of the line.</param>
            <param name="x2">The second X position of the line.</param>
            <param name="y2">The second Y position of the line.</param>
            <returns>The distance from the point to the line.</returns>
        </member>
        <member name="P:Murder.Services.MurderUiServices.BoxUiInfo.BoxFade">
            <summary>
            Fade applied on the box when transitioning.
            </summary>
        </member>
        <member name="P:Murder.Services.MurderUiServices.BoxUiInfo.TextFade">
            <summary>
            Fade applied on the text when transitioning.
            Used when only the text fades.
            </summary>
        </member>
        <member name="P:Murder.Services.MurderUiServices.BoxUiInfo.ExtraHeight">
            <summary>
            Value used when an extra height is required after the text when drawing the box.
            </summary>
        </member>
        <member name="P:Murder.Services.MurderUiServices.ButtonInfo.MenuInfo">
            <summary>
            This is used when multiple buttons are displayed.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.GetColliderBoundingBox(Bang.Entities.Entity)">
            <summary>
            Get bounding box of an entity that contains both <see cref="T:Murder.Components.ColliderComponent"/>
            and <see cref="T:Murder.Components.PositionComponent"/>.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.RaycastTiles(Bang.World,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,System.Int32,Murder.Services.PhysicsServices.RaycastHit@)">
            <summary>
            Tryies to raycast looking for tile collisions.
            </summary>
            <param name="world"></param>
            <param name="startPosition"></param>
            <param name="endPosition"></param>
            <param name="flags"></param>
            <param name="hit"></param>
            <returns>Returns true if it hits a tile</returns>
        </member>
        <member name="M:Murder.Services.PhysicsServices.Raycast(Bang.World,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2,System.Int32,System.Collections.Generic.IEnumerable{System.Int32},Murder.Services.PhysicsServices.RaycastHit@)">
            <summary>
            TODO: Implement
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.FindNextAvailablePosition(Bang.World,Bang.Entities.Entity,Murder.Core.Geometry.Vector2)">
            <summary>
            Find an eligible position to place an entity <paramref name="e"/> in the world that does not collide
            with other entities and targets <paramref name="target"/>.
            This will return immediate neighbours if <paramref name="target"/> is already occupied.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.Neighbours(Murder.Core.Geometry.Vector2,Bang.World)">
            <summary>
            Get all the neighbours of a position within the world.
            This does not check for collision (yet)!
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.GetFirstMtvAt(Murder.Core.Map@,System.Collections.Generic.HashSet{System.Int32},Murder.Components.ColliderComponent,Murder.Core.Geometry.Vector2,System.Collections.Generic.IEnumerable{System.ValueTuple{System.Int32,Murder.Components.ColliderComponent,Murder.Components.IMurderTransformComponent}},System.Int32,System.Int32@,Murder.Core.Geometry.Vector2@)">
            <summary>
            Checks for collision at a position, returns the minimum translation vector (MTV) to resolve the collision.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.GetMtvAt(Murder.Core.Map@,System.Int32,Murder.Components.ColliderComponent,Murder.Core.Geometry.Vector2,System.Collections.Generic.IEnumerable{System.ValueTuple{System.Int32,Murder.Components.ColliderComponent,Murder.Components.IMurderTransformComponent}},System.Int32,System.Int32@)">
            <summary>
            Checks for collision at a position, returns the minimum translation vector (MTV) to resolve the collision.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.CollidesAtTile(Murder.Core.Map@,Murder.Components.ColliderComponent,Murder.Core.Geometry.Vector2,System.Int32)">
            <summary>
            Apply collision with tile objects within the map.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.CollidesAtTile(Murder.Core.Map@,Murder.Core.Geometry.IShape,Murder.Core.Geometry.Vector2,System.Int32)">
            <summary>
            Apply collision with tile objects within the map.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.ConeCheck(Bang.World,Murder.Core.Geometry.Vector2,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            Checks for collisions in a cone.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.FindClosestEntityOnRange(Bang.World,Murder.Core.Geometry.Vector2,System.Single,System.Int32,System.Collections.Generic.HashSet{System.Int32},Bang.Entities.Entity@,System.Nullable{Murder.Core.Geometry.Vector2}@)">
            <summary>
            Find the closest entity on a <paramref name="range"/> according to a <paramref name="collisionLayer"/>.
            </summary>
        </member>
        <member name="M:Murder.Services.PhysicsServices.MoveSolidGlobal(Bang.World,Bang.Entities.Entity,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2)">
            <summary>
            Moves an entity to a new position keeping the transform type.
            If the region is already occupied it tries to push away actors is in there.
            This is not a cheap method and it's not optimized for large amounts of entities.
            Uses global position.
            </summary>
            <param name="world"></param>
            <param name="entity"></param>
            <param name="from"></param>
            <param name="to"></param>
        </member>
        <member name="M:Murder.Services.PhysicsServices.RemoveFromCollisionCache(Bang.Entities.Entity,System.Int32)">
            <summary>
            Removes an ID from the IsColliding component. This is usually handled by TriggerPhysics system, since a message must be sent when exiting a collision.
            </summary>
            <param name="entity"></param>
            <param name="entityId"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Services.PhysicsServices.HasCachedCollisionWith(Bang.Entities.Entity,System.Int32)">
            <summary>
            Check if a trigger is colliding with an actor via the TriggerCollisionSystem.
            </summary>
            <param name="entity"></param>
            <param name="entityId"></param>
        </member>
        <member name="T:Murder.Services.RenderServices">
            Some of the code based on https://github.com/z2oh/C3.MonoGame.Primitives2D/blob/master/Primitives2D.cs
        </member>
        <member name="M:Murder.Services.RenderServices.DrawVerticalMenu(Murder.Core.Graphics.RenderContext,Murder.Core.Geometry.Point,Murder.Core.Geometry.Vector2,Murder.Core.Graphics.PixelFont,Murder.Core.Graphics.Color,Murder.Core.Graphics.Color,Murder.Core.Graphics.Color,System.Int32,Murder.Core.Geometry.Point@,System.Collections.Generic.IList{Murder.Services.MenuOption})">
            <summary>
            TODO: Pass around a "style" for background color, sounds, etc.
            </summary>
        </member>
        <member name="M:Murder.Services.RenderServices.Draw9Slice(Murder.Core.Graphics.Batch2D,System.Guid,Murder.Core.Geometry.Rectangle,System.String,Murder.Core.Graphics.DrawInfo)">
            <summary>
            Draws a 9-slice using the given texture and target rectangle. The core rectangle is specified in the Aseprite file
            </summary>
        </member>
        <member name="M:Murder.Services.RenderServices.DrawSprite(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,System.String,Murder.Assets.Graphics.SpriteAsset,System.Single,System.Single,Murder.Core.Geometry.Vector2,System.Boolean,System.Single,Murder.Core.Geometry.Vector2,Murder.Core.Graphics.Color,Microsoft.Xna.Framework.Vector3,System.Single,System.Boolean)">
            <summary>
            Renders a sprite on the screen
            </summary>
            <param name="spriteBatch">Sprite batch.</param>
            <param name="pos">Position in the render.</param>
            <param name="animationId">Animation string id.</param>
            <param name="ase">Aseprite asset.</param>
            <param name="animationStartedTime">When the animation started.</param>
            <param name="animationDuration">The total duration of the animation. Use -1 to use the duration from the aseprite file.</param>
            <param name="offset">Offset from <paramref name="pos"/>. From 0 to 1.</param>
            <param name="flipped">Whether the image is flipped.</param>
            <param name="rotation">Rotation of the image, in radians.</param>
            <param name="scale">Scale applied to the sprite.</param>
            <param name="color">Color.</param>
            <param name="blend">Blend.</param>
            <param name="sort">Sort layer. 0 is in front, 1 is behind</param>
            <param name="useScaledTime">If true, this will use the escaled time and will pause whenever the game is paused.</param>
            <returns>If the animation is complete or not</returns>
        </member>
        <member name="M:Murder.Services.RenderServices.DrawSpriteWithOutline(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,System.String,Murder.Assets.Graphics.SpriteAsset,System.Single,System.Single,Murder.Core.Geometry.Vector2,System.Boolean,System.Single,Murder.Core.Graphics.Color,Microsoft.Xna.Framework.Vector3,System.Single,System.Boolean)">
            <summary>
            Renders a sprite on the screen
            </summary>
            <param name="spriteBatch">Target sprite batch.</param>
            <param name="pos">Position of the animation.</param>
            <param name="animationId">Animation unique identifier.</param>
            <param name="ase">Target aseprite asset.</param>
            <param name="animationStartedTime">When the animation has started within the game.</param>
            <param name="animationDuration">The total duration of the animation. Use -1 to use the duration from the aseprite file.</param>
            <param name="offset">Offset from <paramref name="pos"/>.</param>
            <param name="flipped">Whether the animation is flipped.</param>
            <param name="rotation">Rotation of the sprite.</param>
            <param name="color">Color to apply in the sprite.</param>
            <param name="blend">The blend style to be used by the shader. Use the constants in <see cref="T:Murder.Services.RenderServices"/>.</param>
            <param name="sort">Sorting order when displaying the sprite.</param>
            <param name="useScaledTime">If true, this will use the escaled time and will pause whenever the game is paused.</param>
            <returns>If the animation is complete or not</returns>
        </member>
        <member name="M:Murder.Services.RenderServices.DrawPoints(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2[],Murder.Core.Graphics.Color,System.Single)">
            <summary>
            Draws a list of connecting points
            </summary>
            <param name="spriteBatch">The destination drawing surface</param>
            /// <param name="position">Where to position the points</param>
            <param name="points">The points to connect with lines</param>
            <param name="color">The color to use</param>
            <param name="thickness">The thickness of the lines</param>
        </member>
        <member name="M:Murder.Services.RenderServices.DrawCircle(Murder.Core.Graphics.Batch2D,Murder.Core.Geometry.Vector2,System.Single,System.Int32,Murder.Core.Graphics.Color,System.Single)">
            <summary>
            Draw a circle
            </summary>
            <param name="spriteBatch">The destination drawing surface</param>
            <param name="center">The center of the circle</param>
            <param name="radius">The radius of the circle</param>
            <param name="sides">The number of sides to generate</param>
            <param name="color">The color of the circle</param>
            <param name="sort">The sorting value</param>
        </member>
        <member name="P:Murder.Services.MenuOption.Length">
            <summary>
            Length of the text option.
            </summary>
        </member>
        <member name="M:Murder.StateMachines.Coroutine.None">
            <summary>
            This is called if this was created without a routine, for whatever reason (it shouldn't).
            </summary>
        </member>
        <member name="T:Murder.Systems.AgentMoverSystem">
            <summary>
            System that looks for AgentImpulse systems and translated them into 'Velocity' for the physics system.
            </summary>
        </member>
        <member name="T:Murder.Systems.Agents.AgentMoveToSystem">
            <summary>
            Simple system for moving agents to another position. Looks for 'MoveTo' components and adds agent inpulses to it.
            </summary>
        </member>
        <member name="M:Murder.Systems.Graphics.SpriteThreeSliceRenderSystem.Draw(Murder.Core.Graphics.RenderContext,Bang.Contexts.Context)">
            <summary>
            This draws an aseprite three slice component.
            TODO: Support animations?
            </summary>
        </member>
        <member name="T:Murder.Systems.AnimationOnPauseSystem">
            <summary>
            System that will automatically completes aseprites on a freeze cutscene.
            </summary>
        </member>
        <member name="T:Murder.Systems.MoveToPerfectSystem">
            <summary>
            Simple system for moving agents to another position. Looks for 'MoveTo' components and adds agent inpulses to it.
            </summary>
        </member>
        <member name="M:Murder.Utilities.AssetHelpers.GetGameAssetPath(Murder.Assets.GameAsset)">
            <summary>
            Get the path to load or save <paramref name="asset"/>.
            </summary>
        </member>
        <member name="T:Murder.Utilities.Attributes.CollisionLayerAttribute">
            <summary>
            Use to signal an Int field to use a drop down selector using constant fields of any class deriving from <see cref="T:Murder.Core.Physics.CollisionLayersBase"/>
            </summary>
        </member>
        <member name="T:Murder.Utilities.Attributes.ChildIdAttribute">
            <summary>
            Attribute for string fields that point to an entity child id.
            </summary>
        </member>
        <member name="T:Murder.Utilities.Attributes.StoryAttribute">
            <summary>
            Attribute used for IComponent structs that will change according to 
            a "story". This is used for debugging and filtering in editor.
            </summary>
        </member>
        <member name="T:Murder.Utilities.Attributes.RuntimeOnlyAttribute">
            <summary>
            This is an attribute for components which will not be added during with
            an editor in saved world or asset, but rather dynamically added in runtime.
            </summary>
        </member>
        <member name="T:Murder.Utilities.CacheDictionary`2">
            <summary>
            A dictionary that has a maximum amount of entries and discards old entries as new ones are added
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:Murder.Utilities.Calculator">
            <summary>
            Calculator helper class.
            </summary>
        </member>
        <member name="F:Murder.Utilities.Calculator.LayersCount">
            <summary>
            Default layers count.
            TODO: Make this customizable.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Calculator.AddOnce``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Add <paramref name="item"/> to <paramref name="list"/>. Skip if already present.
            Cost O(n).
            </summary>
        </member>
        <member name="M:Murder.Utilities.Calculator.ClampTime(System.Single,System.Single)">
            <summary>
            Takes an elapsed time and coverts it to a 0-1 range
            </summary>
            <param name="elapsed"></param>
            <param name="maxTime"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Murder.Utilities.Calculator.RoundToInt(System.Single)">
            <summary>
            Rounds and converts a number to integer with <see cref="M:System.MathF.Round(System.Single)"/>.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Calculator.IsAlmostZero(System.Single)">
            <summary>
            Returns if a value if zero withing a margin of error. (epsilon)
            </summary>
            <param name="value"></param>
            <returns></returns>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:Murder.Utilities.Calculator.CleverSign(System.Single)">
            <summary>
            Returns the sign of a value. 1 if positive or Zero, -1 if negative.
            </summary>
        </member>
        <member name="M:Murder.Utilities.ColorHelper.ToVector4Color(System.String)">
            <summary>
            Parses a string <paramref name="hex"/> to <see cref="T:System.Numerics.Vector4"/>.
            </summary>
            <param name="hex">The string as the hex value, e.g. "#ff5545".</param>
            <returns>The converted color.</returns>
        </member>
        <member name="T:Murder.Utilities.Ease">
            <summary>
            Static class with useful easer functions that can be used by Tweens.
            This was copied from:
            https://github.com/kylepulver/Otter/blob/master/Otter/Utility/Glide/Ease.cs
            </summary>
            <summary>
            Static class with useful easer functions that can be used by Tweens.
            This was copied from:
            https://github.com/kylepulver/Otter/blob/master/Otter/Utility/Glide/Ease.cs
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.ToAndFrom(System.Func{System.Single,System.Single})">
            <summary>
            Ease a value to its target and then back. Use this to wrap another easing function.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.Evaluate(System.Single,Murder.Utilities.EaseKind)">
            <summary>
            Do an ease according to <paramref name="kind"/>.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.ToAndFrom(System.Single)">
            <summary>
            Ease a value to its target and then back.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.Linear(System.Single)">
            <summary>
            Linear.
            </summary>
            <param name="t">Time.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ElasticIn(System.Single)">
            <summary>
            Elastic in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ElasticOut(System.Single)">
            <summary>
            Elastic out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ElasticInOut(System.Single)">
            <summary>
            Elastic in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuadIn(System.Single)">
            <summary>
            Quadratic in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuadOut(System.Single)">
            <summary>
            Quadratic out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuadInOut(System.Single)">
            <summary>
            Quadratic in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CubeIn(System.Single)">
            <summary>
            Cubic in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CubeOut(System.Single)">
            <summary>
            Cubic out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CubeInOut(System.Single)">
            <summary>
            Cubic in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuartIn(System.Single)">
            <summary>
            Quart in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuartOut(System.Single)">
            <summary>
            Quart out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuartInOut(System.Single)">
            <summary>
            Quart in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuintIn(System.Single)">
            <summary>
            Quint in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuintOut(System.Single)">
            <summary>
            Quint out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuintInOut(System.Single)">
            <summary>
            Quint in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.SineIn(System.Single)">
            <summary>
            Sine in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.SineOut(System.Single)">
            <summary>
            Sine out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.SineInOut(System.Single)">
            <summary>
            Sine in and out
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BounceIn(System.Single)">
            <summary>
            Bounce in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BounceOut(System.Single)">
            <summary>
            Bounce out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BounceInOut(System.Single)">
            <summary>
            Bounce in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CircIn(System.Single)">
            <summary>
            Circle in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CircOut(System.Single)">
            <summary>
            Circle out
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CircInOut(System.Single)">
            <summary>
            Circle in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ExpoIn(System.Single)">
            <summary>
            Exponential in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ExpoOut(System.Single)">
            <summary>
            Exponential out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ExpoInOut(System.Single)">
            <summary>
            Exponential in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackIn(System.Single)">
            <summary>
            Back in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackOutSm(System.Single)">
            <summary>
            Back out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackOut(System.Single)">
            <summary>
            Back out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackInOut(System.Single)">
            <summary>
            Back in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ToAndFrom(System.Func{System.Double,System.Double})">
            <summary>
            Ease a value to its target and then back. Use this to wrap another easing function.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.Evaluate(System.Double,Murder.Utilities.EaseKind)">
            <summary>
            Do an ease according to <paramref name="kind"/>.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.ToAndFrom(System.Double)">
            <summary>
            Ease a value to its target and then back.
            </summary>
        </member>
        <member name="M:Murder.Utilities.Ease.Linear(System.Double)">
            <summary>
            Linear.
            </summary>
            <param name="t">Time.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ElasticIn(System.Double)">
            <summary>
            Elastic in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ElasticOut(System.Double)">
            <summary>
            Elastic out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ElasticInOut(System.Double)">
            <summary>
            Elastic in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuadIn(System.Double)">
            <summary>
            Quadratic in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuadOut(System.Double)">
            <summary>
            Quadratic out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuadInOut(System.Double)">
            <summary>
            Quadratic in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CubeIn(System.Double)">
            <summary>
            Cubic in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CubeOut(System.Double)">
            <summary>
            Cubic out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CubeInOut(System.Double)">
            <summary>
            Cubic in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuartIn(System.Double)">
            <summary>
            Quart in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuartOut(System.Double)">
            <summary>
            Quart out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuartInOut(System.Double)">
            <summary>
            Quart in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuintIn(System.Double)">
            <summary>
            Quint in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuintOut(System.Double)">
            <summary>
            Quint out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.QuintInOut(System.Double)">
            <summary>
            Quint in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.SineIn(System.Double)">
            <summary>
            Sine in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.SineOut(System.Double)">
            <summary>
            Sine out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.SineInOut(System.Double)">
            <summary>
            Sine in and out
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BounceIn(System.Double)">
            <summary>
            Bounce in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BounceOut(System.Double)">
            <summary>
            Bounce out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BounceInOut(System.Double)">
            <summary>
            Bounce in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CircIn(System.Double)">
            <summary>
            Circle in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CircOut(System.Double)">
            <summary>
            Circle out
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.CircInOut(System.Double)">
            <summary>
            Circle in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ExpoIn(System.Double)">
            <summary>
            Exponential in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ExpoOut(System.Double)">
            <summary>
            Exponential out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.ExpoInOut(System.Double)">
            <summary>
            Exponential in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackIn(System.Double)">
            <summary>
            Back in.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackOutSm(System.Double)">
            <summary>
            Back out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackOut(System.Double)">
            <summary>
            Back out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="M:Murder.Utilities.Ease.BackInOut(System.Double)">
            <summary>
            Back in and out.
            </summary>
            <param name="t">Time elapsed.</param>
            <returns>Eased timescale.</returns>
        </member>
        <member name="T:Murder.Utilities.EaseKind">
            <summary>
            Specifies an easing technique.
            </summary>
        </member>
        <member name="M:Murder.Utilities.GridHelper.Neighbours(Murder.Core.Geometry.Point,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns all the neighbours of a position.
            </summary>
        </member>
        <member name="M:Murder.Utilities.GridHelper.Neighbours(Murder.Core.Geometry.Point,System.Int32,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns all the neighbours of a position.
            </summary>
        </member>
        <member name="M:Murder.Utilities.GridHelper.FromTopLeftToBottomRight(Murder.Core.Geometry.Point,Murder.Core.Geometry.Point)">
            <summary>
            Creates a rectangle from <paramref name="p1"/> to <paramref name="p2"/>.
            </summary>
        </member>
        <member name="M:Murder.Utilities.GridHelper.FromTopLeftToBottomRight(Murder.Core.Geometry.Vector2,Murder.Core.Geometry.Vector2)">
            <summary>
            Creates a rectangle from <paramref name="p1"/> to <paramref name="p2"/>.
            </summary>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.#cctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.FractionalBrownianMotion(Murder.Utilities.NoiseType,System.Int32,System.Single,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Generates a 2D Fractional Brownian Motion noise on top of Simplex noise generated
            </summary>
            <param name="type">Carmody or Gustavson Noise</param>
            <param name="height">Height of the grid being generated</param>
            <param name="x">X position</param>
            <param name="y">Y position</param>
            <param name="octaves">Number of layers</param>
            <param name="gain">Persistence, makes amplitude shrink or not shrink (0.5f is standard with Lacunarity of 2.0f)</param>
            <param name="lacunarity">Multiplied with frequency every octave (2.0f is standard)</param>
            <returns>Noise value for input parameters</returns>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.FractionalBrownianMotion(Murder.Utilities.NoiseType,System.Int32,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            Generates a 3D Fractional Brownian Motion noise on top of Simplex noise generated
            </summary>
            <param name="type">Carmody or Gustavson Noise</param>
            <param name="height">Height of the grid being generated</param>
            <param name="x">X position</param>
            <param name="y">Y position</param>
            <param name="z">Z position</param>
            <param name="octaves">Number of layers</param>
            <param name="gain">Persistence, makes amplitude shrink or not shrink (0.5f is standard with Lacunarity of 2.0f)</param>
            <param name="lacunarity">Multiplied with frequency every octave (2.0f is standard)</param>
            <returns>Noise value for input parameters</returns>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.CarmodyNoise(System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Carmody's implementation of a Simplex Noise generator
            </summary>
            <param name="x">X position</param>
            <param name="y">Y position</param>
            <param name="z">Z position</param>
            <param name="doReseed">Force reseeding of the permutations array</param>
            <param name="doNormalize">Normalize to [0 .. 1] instead</param>
            <returns>A value in the range of about [-1 .. 1]</returns>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.GustavsonNoise(System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Gustavson's implementation of a 2D Simplex Noise generator
            </summary>
            <param name="xin">X position</param>
            <param name="yin">Y Position</param>
            <param name="doRecalculate">Force recalculations of permutations (can also be done by setting the NoiseHelper.Seed property)</param>
            <param name="doNormalize">Normalize the output to 0.0 .. 1.0</param>
            <returns>A value in the range of about -1.0 .. 1.0</returns>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.GustavsonNoise(System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Gustavson's implementation of a 3D Simplex Noise generator
            </summary>
            <param name="xin">X position</param>
            <param name="yin">Y Position</param>
            <param name="zin">Z position</param>
            <param name="doRecalculate">Force recalculations of permutations (can also be done by setting the NoiseHelper.Seed property)</param>
            <param name="doNormalize">Whether data should be noramlized after the computation.</param>
            <returns>A value in the range of about -1.0 .. 1.0</returns>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.Normalize(System.Single,System.Single,System.Single)">
            <summary>
            Normalizes a float to the range of 0 to 1
            </summary>
            <param name="value">The float to be normalized</param>
            <param name="min">The minimum value in the range</param>
            <param name="max">The maximum value in the range</param>
            <returns>The normalized float</returns>
        </member>
        <member name="M:Murder.Utilities.NoiseHelper.NormalizeSigned(System.Single,System.Single,System.Single)">
            <summary>
            Normalizes a float to the range of -1 to 1
            </summary>
            <param name="value">The float to be normalized</param>
            <param name="min">The minimum value in the range</param>
            <param name="max">The maximum value in the range</param>
            <returns>The normalized float</returns>
        </member>
        <member name="M:Murder.Utilities.PositionExtensions.Neighbours(Murder.Core.Geometry.Vector2,System.Int32,System.Int32)">
            <summary>
            Returns all the neighbour positions of a position with an offset of the grid size.
            This does not check the boundaries of a grid.
            </summary>
        </member>
        <member name="M:Murder.Utilities.RandomExtensions.TryWithChanceOf(System.Random,System.Int32)">
            <summary>
            Flag a switch with a chance of <paramref name="chance"/>%.
            </summary>
            <param name="random">The amound of odds of hitting that particular switch.</param>
            <param name="chance">Chance of succeeding.</param>
        </member>
        <member name="M:Murder.Utilities.RandomExtensions.TryWithChanceOf(System.Random,System.Single)">
            <summary>
            Flag a switch with a chance of <paramref name="chance"/>.
            </summary>
            <param name="random">The amound of odds of hitting that particular switch.</param>
            <param name="chance">Chance of succeeding. From 0 to 1</param>
        </member>
        <member name="M:Murder.Utilities.RandomExtensions.GetRandom``1(System.Random,``0[],System.Int32)">
            <summary>
            Get up to <paramref name="length"/> random elements in <paramref name="array"/>.
            </summary>
        </member>
        <member name="M:Murder.Utilities.SerializationHelper.DeepCopy``1(``0)">
            <summary>
            This is really tricky. We currently use readonly structs everywhere, which is great
            and very optimized.
            HOWEVER, this is tricky in the editor serializer. We need an actual new copy
            so we don't modify any other IComponents which are using the same memory.
            In order to workaround that, we will literally serialize a new component and create its copy.
            </summary>
        </member>
        <member name="M:Murder.Utilities.StringHelper.Cleanup(System.String)">
            <summary>
            Removes single returns, keeps doubles.
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Murder.Attributes.AngleAttribute">
            <summary>
            An attribute for angle fields. This will show up in the editor
            as a {0, 360} range, but converted in radius in the actual field.
            </summary>
        </member>
        <member name="T:Murder.Attributes.AtlasCoordinatesAttribute">
            <summary>
            This is an attribute used for field strings that point to an atlas texture.
            </summary>
        </member>
        <member name="T:Murder.Attributes.DoNotPersistEntityOnSaveAttribute">
            <summary>
            This signalizes that an entity should be skipped altogether if
            it has a component with that attribute.
            </summary>
        </member>
        <member name="T:Murder.Attributes.ShowInEditorAttribute">
            <summary>
            Attributes for fields that should always show up in the editor.
            Commonly used for private fields.
            </summary>
        </member>
        <member name="T:Murder.Attributes.SliderAttribute">
            <summary>
            A slider attribute used when setting values in the editor.
            </summary>
        </member>
        <member name="F:Murder.Attributes.SliderAttribute.Minimum">
            <summary>
            Minimum value.
            </summary>
        </member>
        <member name="F:Murder.Attributes.SliderAttribute.Maximum">
            <summary>
            Maximum value.
            </summary>
        </member>
        <member name="M:Murder.Attributes.SliderAttribute.#ctor(System.Single,System.Single)">
            <summary>
            Creates a new <see cref="T:Murder.Attributes.SliderAttribute"/>.
            </summary>
            <param name="minimum">Minimum value.</param>
            <param name="maximum">Maximum value.</param>
        </member>
        <member name="T:Murder.Attributes.TooltipAttribute">
            <summary>
            Tooltip that will show up when hovering over a field in the editor.
            </summary>
        </member>
        <member name="F:Murder.Attributes.TooltipAttribute.Text">
            <summary>
            The content of the tooltip.
            </summary>
        </member>
        <member name="M:Murder.Attributes.TooltipAttribute.#ctor(System.String)">
            <summary>
            Creates a new <see cref="T:Murder.Attributes.TooltipAttribute"/>.
            </summary>
            <param name="text">The content of the tooltip.</param>
        </member>
        <member name="T:Murder.Attributes.GameAssetDictionaryIdAttribute">
            <summary>
            This is an attribute used for a dictionary with a guid on both the key and values.
            </summary>
        </member>
        <member name="F:Murder.Attributes.GameAssetDictionaryIdAttribute.Key">
            <summary>
            The type of the game asset key.
            </summary>
        </member>
        <member name="F:Murder.Attributes.GameAssetDictionaryIdAttribute.Value">
            <summary>
            The type of the game asset value.
            </summary>
        </member>
        <member name="M:Murder.Attributes.GameAssetDictionaryIdAttribute.#ctor(System.Type,System.Type)">
            <summary>
            Creates a new <see cref="T:Murder.Attributes.GameAssetDictionaryIdAttribute"/>.
            </summary>
        </member>
        <member name="T:Murder.Attributes.GameAssetIdAttribute">
            <summary>
            This is an attribute used for a field guid that point to a game asset id.
            </summary>
        </member>
        <member name="F:Murder.Attributes.GameAssetIdAttribute.AssetType">
            <summary>
            The type of the game asset.
            </summary>
        </member>
        <member name="M:Murder.Attributes.GameAssetIdAttribute.#ctor(System.Type)">
            <summary>
            Creates a new <see cref="T:Murder.Attributes.GameAssetIdAttribute"/>.
            </summary>
            <param name="type">The game asset type.</param>
        </member>
        <member name="T:Murder.Attributes.InstanceIdAttribute">
            <summary>
            This is an attribute used for a field guid that points to another entity instance within the world.
            </summary>
        </member>
        <member name="T:Murder.Attributes.IntrinsicAttribute">
            <summary>
            This signalizes that a component is an intrinsic characteristic of the entity and 
            that it does not distinct as a separate entity.
            An entity with only intrinsic components will not be serialized.
            </summary>
        </member>
        <member name="T:Murder.Attributes.PersistOnSaveAttribute">
            <summary>
            Overrides any other attribute and make sure this component is persisted in
            the entity serialization.
            </summary>
        </member>
        <member name="T:Murder.Attributes.SoundAttribute">
            <summary>
            Attribute that a field references a sound.
            </summary>
        </member>
        <member name="T:Murder.Attributes.TypeOfAttribute">
            <summary>
            Attribute for looking on a <see cref="F:Murder.Attributes.TypeOfAttribute.Type"/> with specific properties.
            </summary>
        </member>
        <member name="M:Murder.Attributes.TypeOfAttribute.#ctor(System.Type)">
            <summary>
            Creates a new <see cref="T:Murder.Attributes.TypeOfAttribute"/>.
            </summary>
            <param name="type">The base type which we will look for implementations.</param>
        </member>
        <member name="T:Murder.Editor.Attributes.OnlyShowOnDebugViewAttribute">
            <summary>
            Indicates that a system will only be displayed on debug.
            </summary>
        </member>
        <member name="T:Murder.Helpers.Direction">
            <summary>
            8 directions, enumerated counterclockwise, starting from right = 0:
            </summary>
        </member>
        <member name="M:Murder.Helpers.DirectionHelper.Angle(Murder.Helpers.Direction)">
            <summary>
            The angle of the direction, in radians.
            </summary>
            <param name="direction"></param>
            <returns></returns>
        </member>
        <member name="M:Murder.Helpers.DirectionHelper.GetSuffixFromAngle(Murder.Components.AgentSpriteComponent,System.Single)">
            <summary>
            Get the suffix from a suffix list based on an angle
            </summary>
            <param name="sprite"></param>
            <param name="angle"></param>
            <returns></returns>
        </member>
        <member name="T:Murder.Serialization.ComplexDictionary`2">
            <summary>
            When serializing dictionaries, Newtonsoft is not able to resolve custom dictionary keys.
            As a workaround for that, we will implement our own complex dictionary which serializes its keys
            as a value tuple, with <see cref="T:Newtonsoft.Json.JsonArrayAttribute"/>.
            </summary>
        </member>
        <member name="T:Murder.Serialization.FileHelper">
            <summary>
            FileHelper which will do OS operations. This is system-agnostic.
            </summary>
        </member>
        <member name="M:Murder.Serialization.FileHelper.GetPath(System.String[])">
            <summary>
            Gets the rooted path from a relative one
            </summary>
            <param name="paths"></param>
            <returns></returns>
        </member>
        <member name="F:Murder.Serialization.FileHelper._compressedSettings">
            <summary>
            Settings when serializing compressed json files.
            </summary>
        </member>
        <member name="M:Murder.Serialization.FileHelper.DeleteContent(System.String@,System.Boolean)">
            <summary>
            Delete all directories in <paramref name="fullpath"/>.
            </summary>
            <param name="fullpath">Complete rooted path.</param>
            <param name="deleteRootFiles">Whether we should also delete the files in the root path.</param>
        </member>
        <member name="M:Murder.Serialization.FileHelper.FileExists(System.String@)">
            This is required since some systems may do a case sensitive search (and we don´t want that)
        </member>
        <member name="M:Murder.Serialization.FileHelper.TryGetLastWrite(System.String)">
            <summary>
            This will iterate recursively over all files in <paramref name="path"/> and return
            the latest modified date.
            </summary>
        </member>
        <member name="M:Murder.Serialization.FileHelper.CreateDirectoryPathIfNotExists(System.String)">
            <summary>
            This will create a directory on the root of this <paramref name="filePath"/>,
            if the directory is not available.
            </summary>
        </member>
        <member name="M:Murder.Serialization.FileHelper.RemoveExtension(System.String)">
            <summary>
            Remove extension from a string.
            </summary>
        </member>
        <member name="T:Murder.Serialization.WritablePropertiesOnlyResolver">
            <summary>
            Custom contract resolver for serializing our game assets.
            This currently filters out getters and filters in readonly fields.
            </summary>
        </member>
        <member name="M:Murder.Serialization.WritablePropertiesOnlyResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
            <summary>
            Only create properties that are able to be set.
            See: https://stackoverflow.com/a/18548894.
            </summary>
        </member>
        <member name="M:Murder.Serialization.WritablePropertiesOnlyResolver.CreateProperty(System.Reflection.MemberInfo,Newtonsoft.Json.MemberSerialization)">
            <summary>
            While we ignore getter properties, we do not want to ignore readonly fields.
            </summary>
        </member>
        <member name="M:Murder.Serialization.WritablePropertiesOnlyResolver.GetSerializableMembers(System.Type)">
            <summary>
            Make sure we fetch all the fields that define [ShowInEditor] in addition to JsonProperty.
            </summary>
        </member>
        <member name="M:AssetServices.Create(Bang.World,System.Guid)">
            <summary>
            Creates an entity using the EntityAsset with the provided GUID and adds it to the world.
            </summary>
        </member>
        <member name="M:AssetServices.TryCreate(Bang.World,System.Guid)">
            <summary>
            Try to create an entity using the EntityAsset with the provided GUID and adds it to the world.
            </summary>
        </member>
    </members>
</doc>
